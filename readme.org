:PROPERTIES:
:GPTEL_MODEL: gemini-2.0-pro-exp-02-05
:GPTEL_BACKEND: Gemini
:GPTEL_SYSTEM: You are a large language model living in Emacs and a helpful assistant. Respond concisely.
:GPTEL_BOUNDS: ((39184 . 39290) (39291 . 39296) (39298 . 39303) (39304 . 39307) (39309 . 39327) (39329 . 39413) (39415 . 39435) (39437 . 39440) (39441 . 39450) (39453 . 39467) (39469 . 39480) (39482 . 39489) (39490 . 39497) (39499 . 39503) (39505 . 39510) (39513 . 39519) (39520 . 39530) (39531 . 39545) (39547 . 39561) (39562 . 39574) (39576 . 39580) (39582 . 39589) (39591 . 39603) (39605 . 39613) (39615 . 39625) (39627 . 39639) (39641 . 39658) (39660 . 39665) (39667 . 39673) (39674 . 39695) (39697 . 39701) (39703 . 39712) (39714 . 39726) (39728 . 39740) (39742 . 39760) (39762 . 39775) (39776 . 39781) (39783 . 39787) (39789 . 39809) (39811 . 39814) (39816 . 39819) (39821 . 39839) (39841 . 39857) (39858 . 39876) (39878 . 39889) (39890 . 39917) (39918 . 39933) (39935 . 39946) (39948 . 39958) (39960 . 39965) (39967 . 39974) (39976 . 40006) (40007 . 40026) (40028 . 40040) (40042 . 40064) (40066 . 40077) (40078 . 40086) (40088 . 40099) (40101 . 40112) (40113 . 40129) (40131 . 40150) (40152 . 40158) (40160 . 40174) (40176 . 40201) (40202 . 40210) (40211 . 40220) (40222 . 40242) (40244 . 40258) (40259 . 40293) (40294 . 40296) (40297 . 40307) (40308 . 40315) (40317 . 40319) (40321 . 40335) (40337 . 40356) (40360 . 40363) (40365 . 40367) (40369 . 40383) (40387 . 40394) (40396 . 40400) (40402 . 40408) (40412 . 40419) (40421 . 40423) (40425 . 40432) (40434 . 40443) (40445 . 40466) (40468 . 40482) (40486 . 40488) (40489 . 40499) (40500 . 40517) (40518 . 40536) (40539 . 40544) (40547 . 40571) (40573 . 40575) (40577 . 40608) (40610 . 40612) (40614 . 40628) (40629 . 40640) (40643 . 40656) (40658 . 40669) (40671 . 40697) (40699 . 40709) (40710 . 40714) (40715 . 40724) (40725 . 40732) (40735 . 40742) (40744 . 40746) (40748 . 40750) (40751 . 40755) (40757 . 40771) (40773 . 40782) (40783 . 40792) (40794 . 40806) (40807 . 40823) (40825 . 40836) (40837 . 40845) (40847 . 40849) (40853 . 40876) (40878 . 40880) (40882 . 40907) (40909 . 40920) (40921 . 40944) (40946 . 40952) (40954 . 40973) (40975 . 40989) (40991 . 41002) (41003 . 41016) (41018 . 41021) (41026 . 41055) (41057 . 41065) (41067 . 41080) (41082 . 41091) (41093 . 41114) (41116 . 41134) (41136 . 41148) (41149 . 41151) (41152 . 41162) (41163 . 41177) (41179 . 41203) (41205 . 41217) (41218 . 41226) (41227 . 41262) (41263 . 41287) (41289 . 41312) (41314 . 41394) (41396 . 41407) (41409 . 41434) (41436 . 41451) (41453 . 41472) (41473 . 41481) (41483 . 41490) (41492 . 41497) (41499 . 41519) (41521 . 41533) (41535 . 41546) (41548 . 41559) (41560 . 41563) (41566 . 41572) (41573 . 41600) (41602 . 41612) (41614 . 41623) (41625 . 41629) (41631 . 41634) (41636 . 41649) (41651 . 41659) (41661 . 41663) (41665 . 41678) (41680 . 41690) (41691 . 41711) (41713 . 41719) (41720 . 41764) (41765 . 41784) (41786 . 41794) (41796 . 41801) (41805 . 41829) (41831 . 41844) (41847 . 41851) (41853 . 41872) (41874 . 41886) (41887 . 41902) (41904 . 41920) (41921 . 41927) (41929 . 41932) (41934 . 41942) (41944 . 41949) (41951 . 41953) (41955 . 41966) (41968 . 41977) (41978 . 42003) (42005 . 42014) (42016 . 42020) (42022 . 42023) (42025 . 42030) (42032 . 42042) (42044 . 42053) (42054 . 42066) (42068 . 42083) (42085 . 42094) (42096 . 42117) (42119 . 42121) (42123 . 42140) (42142 . 42149) (42151 . 42155) (42156 . 42157) (42161 . 42171) (42172 . 42191) (42193 . 42215) (42217 . 42219) (42221 . 42234) (42235 . 42322) (42324 . 42334) (42335 . 42337) (42339 . 42346) (42347 . 42363) (42364 . 42368) (42370 . 42372) (42374 . 42379) (42381 . 42384) (42386 . 42398) (42400 . 42413) (42415 . 42432) (42434 . 42444) (42446 . 42469) (42471 . 42490) (42492 . 42501) (42503 . 42508) (42509 . 42513) (42515 . 42531) (42532 . 42587) (42589 . 42597) (42599 . 42609) (42610 . 42710) (42712 . 42724) (42726 . 42734) (42736 . 42746) (42747 . 42821) (42823 . 42828) (42830 . 42840) (42842 . 42849) (42851 . 42862) (42864 . 42867) (42868 . 42881) (42883 . 42893) (42895 . 42916) (42918 . 42923) (42925 . 42929) (42931 . 42943) (42945 . 42951) (42952 . 42956) (42958 . 42970) (42972 . 42987) (42988 . 42991) (42993 . 43006) (43009 . 43019) (43020 . 43028) (43030 . 43041) (43043 . 43047) (43049 . 43067) (43069 . 43072) (43074 . 43079) (43081 . 43102) (43104 . 43135) (43136 . 43143) (43146 . 43149) (43151 . 43152) (43154 . 43155) (43157 . 43158) (43160 . 43164) (43165 . 43192) (43194 . 43206) (43208 . 43222) (43223 . 43237) (43239 . 43255) (43257 . 43266) (43268 . 43288) (43290 . 43295) (43297 . 43303) (43304 . 43310) (43312 . 43319) (43321 . 43331) (43333 . 43346) (43348 . 43360) (43362 . 43371) (43372 . 43404) (43405 . 43442) (43444 . 43485) (43487 . 43502) (43504 . 43507) (43509 . 43523) (43525 . 43534) (43535 . 43538) (43541 . 43568) (43570 . 43581) (43583 . 43588) (43590 . 43618) (43620 . 43633) (43634 . 43653) (43655 . 43680) (43681 . 43703) (43705 . 43711) (43712 . 43987) (43989 . 43992) (43994 . 43996) (43998 . 44009) (44011 . 44024) (44025 . 44052) (44053 . 44067) (44069 . 44084) (44086 . 44097) (44099 . 44104) (44105 . 44115) (44116 . 44137) (44139 . 44160) (44162 . 44180) (44181 . 46252) (46254 . 46280) (46282 . 46292) (46294 . 46297) (46299 . 46302) (46304 . 46308) (46310 . 46319) (46320 . 46324) (46326 . 46329) (46331 . 46343) (46344 . 46355) (46356 . 46366) (46367 . 46372) (46374 . 46391) (46393 . 46403) (46405 . 46415) (46417 . 46419) (46421 . 46437) (46439 . 46580) (46582 . 46600) (46602 . 46632) (46634 . 46645) (46646 . 46650) (46652 . 46662) (46664 . 46683) (46685 . 46686) (46687 . 46697) (46698 . 46699) (46701 . 46720) (46722 . 46728) (46730 . 46750) (46752 . 46764) (46765 . 46771) (46773 . 46785) (46787 . 46801) (46803 . 46844) (46845 . 46873) (46875 . 46882) (46883 . 46891) (46894 . 46911) (46912 . 47701) (47703 . 47719) (47721 . 47729) (47731 . 47739) (47741 . 47755) (47757 . 47788) (47790 . 47796) (47798 . 47807) (47809 . 47816) (47817 . 47836) (47838 . 47853) (47855 . 47868) (47870 . 47872) (47874 . 47875) (47877 . 47880) (47882 . 47887) (47889 . 47897) (47899 . 47909) (47910 . 47937) (47939 . 47952) (47954 . 47962) (47963 . 47971) (47974 . 47981) (47983 . 47985) (47987 . 48032) (48034 . 48068) (48070 . 48119) (48121 . 48133) (48135 . 48150) (48152 . 48179) (48181 . 48183) (48185 . 48200) (48201 . 48230) (48233 . 48245) (48247 . 48257) (48258 . 48274) (48276 . 48280) (48282 . 48291) (48293 . 48307) (48309 . 48322) (48324 . 48337) (48339 . 48342) (48344 . 48354) (48356 . 48366) (48368 . 48376) (48378 . 48390) (48391 . 48414) (48416 . 48426) (48428 . 48430) (48432 . 48438) (48440 . 48447) (48449 . 48451) (48453 . 48472) (48474 . 48483) (48485 . 48494) (48495 . 48503) (48504 . 48519) (48520 . 48541) (48543 . 48560) (48562 . 48569) (48573 . 48593) (48595 . 48619) (48621 . 48631) (48633 . 48646) (48648 . 48652) (48654 . 48658) (48660 . 48677) (48679 . 48691) (48692 . 48704) (48706 . 48708) (48710 . 48713) (48715 . 48722) (48723 . 48725) (48726 . 48732) (48734 . 48738) (48742 . 48744) (48746 . 48748) (48750 . 48776) (48777 . 48802) (48804 . 48837) (48839 . 48848) (48850 . 48871) (48873 . 48875) (48877 . 48884) (48886 . 48899) (48901 . 48914) (48916 . 48935) (48937 . 48948) (48950 . 48965) (48967 . 48977) (48978 . 48991) (48993 . 49035) (49036 . 49330) (49332 . 49343) (49345 . 49350) (49352 . 49369) (49371 . 49381) (49383 . 49390) (49391 . 49395) (49397 . 49418) (49420 . 49426) (49428 . 49452) (49453 . 49477) (49478 . 49483) (49485 . 49494) (49495 . 49533) (49534 . 49547) (49548 . 49558) (49560 . 49573) (49575 . 49618) (49619 . 49632) (49635 . 49642) (49644 . 49686) (49688 . 49705) (49706 . 49727) (49729 . 49747) (49748 . 49766) (49768 . 49770) (49772 . 49783) (49785 . 49795) (49797 . 49799) (49801 . 49841) (49842 . 49877) (49879 . 49886) (49888 . 49896) (49898 . 49902) (49904 . 49930) (49931 . 49937) (49939 . 49952) (49954 . 49970) (49972 . 49974) (49975 . 50067) (50069 . 50079) (50081 . 50092) (50093 . 50110) (50112 . 50127) (50129 . 50133) (50135 . 50152) (50153 . 50158) (50160 . 50185) (50187 . 50201) (50203 . 50226) (50228 . 50247) (50249 . 50259) (50261 . 50316) (50318 . 50351) (50352 . 50368) (50370 . 50382) (50384 . 50404) (50406 . 50473) (50474 . 50497) (50499 . 50505) (50506 . 50516) (50517 . 50527) (50529 . 50538) (50540 . 50561) (50562 . 50572) (50574 . 50618) (50620 . 50649) (50651 . 50653) (50655 . 50683) (50685 . 50706) (50708 . 50728) (50729 . 50768) (50770 . 50786) (50787 . 50805) (50807 . 50830) (50832 . 50838) (50840 . 50850) (50852 . 50865) (50867 . 50878) (50880 . 50893) (50894 . 50898) (50901 . 50908) (50910 . 50944) (50946 . 50964) (50966 . 50974) (50976 . 50994) (50996 . 50998) (51000 . 51008) (51010 . 51025) (51027 . 51039) (51041 . 51088) (51090 . 51109) (51110 . 51122) (51124 . 51138) (51140 . 51146) (51148 . 51160) (51162 . 51171) (51172 . 51178) (51180 . 51208) (51210 . 51216) (51218 . 51236) (51238 . 51245) (51247 . 51260) (51262 . 51270) (51272 . 51281) (51282 . 51287) (51289 . 51313) (51314 . 51331) (51332 . 51357) (51359 . 51363) (51365 . 51370) (51372 . 51388) (51390 . 51394) (51396 . 51421) (51423 . 51435) (51437 . 51458) (51460 . 51468) (51469 . 51487) (51488 . 51504) (51505 . 51524) (51525 . 51531) (51533 . 51555) (51557 . 51567) (51568 . 51578) (51579 . 51590) (51593 . 51605) (51607 . 51609) (51611 . 51624) (51626 . 51642) (51643 . 51656) (51658 . 51677) (51679 . 51690) (51692 . 51714) (51716 . 51728) (51730 . 51734) (51736 . 51745) (51746 . 51750) (51752 . 51765) (51769 . 51771) (51773 . 51776) (51777 . 51782) (51783 . 51793) (51795 . 51809) (51811 . 51823) (51824 . 51837) (51840 . 51848) (51849 . 51885) (51887 . 51904) (51905 . 51926) (51927 . 51945) (51947 . 51949) (51950 . 51966) (51967 . 51986) (51987 . 52003) (52005 . 52024) (52026 . 52045) (52047 . 52055) (52057 . 52067) (52068 . 52078) (52080 . 52083) (52085 . 52088) (52090 . 52100) (52102 . 52110) (52112 . 52120) (52122 . 52129) (52130 . 52170) (52172 . 52175) (52177 . 52212) (52214 . 52228) (52229 . 52255) (52257 . 52278) (52280 . 52287) (52289 . 52301) (52303 . 52315) (52317 . 52328) (52329 . 52361) (52363 . 52367) (52368 . 52395) (52397 . 52404) (52406 . 52413) (52415 . 52433) (52434 . 52466) (52468 . 52470) (52472 . 52476) (52479 . 52489) (52490 . 52504) (52506 . 52517) (52519 . 52526) (52528 . 52537) (52538 . 52543) (52544 . 52554) (52555 . 52563) (52564 . 52570) (52572 . 52601) (52603 . 52606) (52608 . 52612) (52614 . 52616) (52618 . 52621) (52623 . 52628) (52630 . 52636) (52638 . 52645) (52647 . 52673) (52675 . 52689) (52695 . 52702) (52704 . 52711) (52713 . 52725) (52726 . 52733) (52735 . 52747) (52749 . 52754) (52756 . 52763) (52765 . 52773) (52775 . 52783) (52785 . 52791) (52793 . 52804) (52806 . 52819) (52822 . 52841) (52842 . 52868) (52870 . 52886) (52887 . 52919) (52921 . 52931) (52933 . 52937) (52939 . 52942) (52943 . 52954) (52955 . 52965) (52966 . 52972) (52974 . 52976) (52978 . 52980) (52982 . 52985) (52987 . 52989) (52991 . 52993) (52995 . 53014) (53016 . 53033) (53035 . 53049) (53051 . 53056) (53058 . 53060) (53062 . 53081) (53085 . 53087) (53089 . 53095) (53097 . 53104) (53106 . 53127) (53128 . 53156) (53158 . 53171) (53172 . 53187) (53189 . 53200) (53202 . 53221) (53223 . 53228) (53229 . 53239) (53240 . 53253) (53255 . 53274) (53275 . 53285) (53286 . 53294) (53297 . 53307) (53308 . 53322) (53323 . 53369) (53371 . 53378) (53380 . 53382) (53385 . 53397) (53399 . 53411) (53412 . 53432) (53434 . 53448) (53450 . 53461) (53463 . 53477) (53479 . 53496) (53497 . 53501) (53503 . 53518) (53520 . 53523) (53525 . 53548) (53550 . 53562) (53563 . 53566) (53567 . 53577) (53578 . 53579) (53581 . 53592) (53594 . 53604) (53606 . 53611) (53612 . 53643) (53644 . 53652) (53654 . 53666) (53668 . 53687) (53689 . 53705) (53707 . 53721) (53723 . 53728) (53730 . 53733) (53735 . 53744) (53747 . 53772) (53774 . 53781) (53783 . 53789) (53791 . 53798) (53800 . 53819) (53821 . 53827) (53829 . 53847) (53848 . 53856) (53858 . 53867) (53869 . 53871) (53873 . 53878) (53880 . 53888) (53890 . 53903) (53904 . 53906) (53909 . 53920) (53921 . 53952) (53954 . 53969) (53971 . 53977) (53979 . 53997) (53999 . 54005) (54007 . 54019) (54021 . 54043) (54045 . 54058) (54059 . 54075) (54077 . 54096) (54098 . 54105) (54107 . 54111) (54113 . 54136) (54138 . 54160) (54161 . 54188) (54190 . 54204) (54206 . 54223) (54225 . 54235) (54237 . 54248) (54250 . 54258) (54260 . 54270) (54272 . 54286) (54287 . 54306) (54307 . 54335) (54337 . 54349) (54351 . 54365) (54366 . 54377) (54380 . 54404) (54406 . 54417) (54419 . 54429) (54431 . 54438) (54440 . 54451) (54453 . 54457) (54459 . 54469) (54471 . 54477) (54479 . 54483) (54485 . 54528) (54529 . 54552) (54553 . 54571) (54573 . 54579) (54580 . 54587) (54588 . 54592) (54594 . 54596) (54598 . 54617) (54618 . 54647) (54648 . 54676) (54677 . 54702) (54703 . 54709) (54711 . 54739) (54741 . 54751) (54752 . 54762) (54763 . 54782) (54783 . 54809) (54811 . 54821) (54823 . 54830) (54831 . 54857) (54859 . 54889) (54891 . 54906) (54907 . 54913) (54915 . 54935) (54937 . 54951) (54953 . 54990) (54991 . 55017) (55019 . 55037) (55039 . 55051) (55053 . 55055) (55057 . 55101) (55103 . 55111) (55113 . 55122) (55123 . 55127) (55129 . 55196) (55198 . 55203) (55205 . 55215) (55217 . 55235) (55237 . 55250) (55252 . 55256) (55258 . 55267) (55268 . 55280) (55282 . 55305) (55307 . 55326) (55328 . 55336) (55338 . 55344) (55346 . 55358) (55360 . 55367) (55369 . 55372) (55374 . 55391) (55393 . 55405) (55406 . 55419) (55421 . 55437) (55439 . 55463) (55465 . 55480) (55481 . 55489) (55492 . 55494) (55496 . 55505) (55509 . 55523) (55525 . 55530) (55534 . 55553) (55555 . 55558) (55560 . 55572) (55574 . 55584) (55586 . 55601) (55603 . 55608) (55609 . 55615) (55617 . 55637) (55639 . 55651) (55653 . 55664) (55665 . 55690) (55692 . 55694) (55695 . 55711) (55713 . 55731) (55733 . 55744) (55745 . 55800) (55802 . 55809) (55811 . 55818) (55820 . 55824) (55826 . 55830) (55832 . 55836) (55838 . 55844) (55846 . 55864) (55866 . 55875) (55877 . 55893) (55895 . 55916) (55917 . 55955) (55957 . 56014) (56015 . 56021) (56023 . 56033) (56035 . 56039) (56041 . 56051) (56053 . 56057) (56059 . 56069) (56071 . 56084) (56086 . 56101) (56103 . 56113) (56115 . 56123) (56124 . 56140) (56142 . 56150) (56152 . 56170) (56172 . 56189) (56191 . 56200) (56202 . 56214) (56216 . 56237) (56239 . 56247) (56248 . 56259) (56261 . 56270) (56272 . 56289) (56290 . 56308) (56310 . 56329) (56331 . 56342) (56344 . 56366) (56368 . 56383) (56385 . 56398) (56400 . 56405) (56407 . 56417) (56419 . 56445) (56446 . 56450) (56452 . 56469) (56471 . 56472) (56474 . 56484) (56488 . 56502) (56504 . 56518) (56519 . 56530) (56533 . 56549) (56552 . 56562) (56565 . 56570) (56572 . 56581) (56583 . 56595) (56596 . 56608) (56610 . 56612) (56614 . 56627) (56629 . 56632) (56634 . 56643) (56645 . 56654) (56656 . 56684) (56685 . 56707) (56709 . 56737) (56738 . 56759) (56761 . 56773) (56775 . 56785) (56787 . 56798) (56800 . 56822) (56824 . 56834) (56836 . 56847) (56848 . 56850) (56851 . 56856) (56858 . 56880) (56881 . 56914) (56916 . 56918) (56922 . 56941) (56942 . 56952) (56955 . 56963) (56964 . 56970) (56971 . 56983) (56985 . 56991) (56992 . 57000) (57001 . 57004) (57006 . 57018) (57020 . 57049) (57050 . 57074) (57076 . 57087) (57089 . 57103) (57105 . 57113) (57115 . 57119) (57121 . 57125) (57127 . 57138) (57139 . 57161) (57163 . 57170) (57172 . 57181) (57183 . 57193) (57197 . 57208) (57210 . 57230) (57232 . 57248) (57249 . 57262) (57263 . 57273) (57275 . 57283) (57285 . 57298) (57299 . 57307) (57310 . 57327) (57328 . 57341) (57343 . 57356) (57358 . 57365) (57366 . 57376) (57378 . 57386) (57388 . 57411) (57413 . 57444) (57446 . 57464) (57466 . 57474) (57476 . 57487) (57488 . 57494) (57495 . 57576) (57578 . 57590) (57592 . 57604) (57605 . 57628) (57630 . 57638) (57639 . 57642) (57644 . 57668) (57669 . 57672) (57673 . 57679) (57681 . 57694) (57696 . 57719) (57721 . 57734) (57735 . 57756) (57758 . 57760) (57762 . 57781) (57784 . 57802) (57804 . 57808) (57810 . 57821) (57822 . 57853) (57855 . 57863) (57865 . 57877) (57878 . 57890) (57891 . 57893) (57895 . 57904) (57906 . 57912) (57917 . 57930) (57932 . 57939) (57941 . 57949) (57950 . 57954) (57956 . 57983) (57985 . 57992) (57993 . 58001) (58003 . 58010) (58011 . 58023) (58025 . 58031) (58033 . 58047) (58049 . 58055) (58057 . 58074) (58075 . 58086) (58088 . 58104) (58106 . 58110) (58112 . 58127) (58129 . 58152) (58154 . 58158) (58160 . 58162) (58164 . 58172) (58174 . 58199) (58201 . 58216) (58218 . 58234) (58235 . 58258) (58260 . 58272) (58274 . 58290) (58292 . 58303) (58305 . 58307) (58309 . 58316) (58318 . 58327) (58329 . 58335) (58337 . 58348) (58350 . 58374) (58376 . 58390) (58392 . 58403) (58405 . 58423) (58425 . 58434) (58436 . 58467) (58469 . 58481) (58483 . 58496) (58498 . 58504) (58506 . 58511) (58512 . 58532) (58534 . 58547) (58549 . 58560) (58562 . 58571) (58573 . 58590) (58591 . 58634) (58636 . 58667) (58669 . 58714) (58716 . 58749) (58751 . 58776) (58778 . 58791) (58793 . 58802) (58804 . 58829) (58831 . 58851) (58853 . 58866) (58867 . 58897) (58898 . 58955) (58957 . 58965) (58967 . 58977) (58978 . 59018) (59019 . 59065) (59067 . 59087) (59088 . 59125) (59127 . 59163) (59164 . 59192) (59193 . 59210) (59212 . 59218) (59220 . 59226) (59228 . 59246) (59247 . 59288) (59290 . 59296) (59298 . 59307) (59308 . 59337) (59339 . 59353) (59355 . 59361) (59363 . 59375) (59377 . 59384) (59386 . 59410) (59412 . 59427) (59428 . 59435) (59437 . 59451) (59453 . 59460) (59462 . 59469) (59470 . 59497) (59499 . 59511) (59513 . 59515) (59517 . 59526) (59527 . 59541) (59543 . 59558) (59560 . 59569) (59571 . 59573) (59574 . 59578) (59580 . 59598) (59600 . 59613) (59615 . 59626) (59628 . 59630) (59632 . 59649) (59650 . 59662) (59664 . 59687) (59689 . 59698) (59700 . 59732) (59733 . 59758) (59760 . 59763) (59765 . 59788) (59790 . 59821) (59823 . 59842) (59844 . 59854) (59856 . 59872) (59874 . 59889) (59891 . 59901) (59902 . 59910) (59912 . 59938) (59940 . 59970) (59971 . 59993) (59995 . 60006) (60008 . 60018) (60020 . 60029) (60031 . 60038) (60040 . 60051) (60053 . 60059) (60061 . 60081) (60083 . 60090) (60092 . 60104) (60106 . 60130) (60131 . 60147) (60149 . 60159) (60161 . 60176) (60178 . 60189) (60191 . 60208) (60210 . 60213) (60215 . 60218) (60219 . 60222) (60223 . 60237) (60239 . 60249) (60250 . 60267) (60269 . 60282) (60284 . 60296) (60298 . 60319) (60321 . 60330) (60331 . 60343) (60345 . 60347) (60352 . 60363) (60364 . 60375) (60377 . 60388) (60390 . 60407) (60409 . 60429) (60430 . 60434) (60436 . 60448) (60450 . 60457) (60459 . 60465) (60467 . 60476) (60478 . 60487) (60489 . 60499) (60501 . 60511) (60512 . 60521) (60523 . 60545) (60547 . 60569) (60571 . 60579) (60581 . 60588) (60589 . 60598) (60600 . 60614) (60616 . 60629) (60631 . 60642) (60643 . 60671) (60673 . 60678) (60680 . 60692) (60693 . 60695) (60698 . 60719) (60721 . 60747) (60749 . 60776) (60778 . 60800) (60801 . 60818) (60820 . 60842) (60843 . 60854) (60856 . 60885) (60887 . 60896) (60898 . 60902) (60904 . 60920) (60922 . 60924) (60926 . 60943) (60945 . 60960) (60961 . 60964) (60967 . 60977) (60979 . 60987) (60989 . 61003) (61005 . 61019) (61021 . 61037) (61039 . 61048) (61050 . 61064) (61066 . 61087) (61089 . 61101) (61103 . 61112) (61113 . 61128) (61130 . 61134) (61136 . 61145) (61147 . 61180) (61182 . 61200) (61202 . 61211) (61213 . 61225) (61227 . 61235) (61236 . 61256) (61257 . 61276) (61278 . 61300) (61302 . 61319) (61320 . 61329) (61331 . 61333) (61335 . 61337) (61339 . 61358) (61360 . 61376) (61378 . 61403) (61405 . 61423) (61424 . 61437) (61439 . 61445) (61447 . 61453) (61454 . 62289) (62291 . 62296) (62298 . 62316) (62318 . 62322) (62324 . 62325) (62327 . 62329) (62331 . 62337) (62340 . 62361) (62362 . 62382) (62384 . 62392) (62394 . 62427) (62428 . 62447) (62449 . 62454) (62456 . 62467) (62469 . 62481) (62483 . 62512) (62514 . 62522) (62524 . 62532) (62534 . 62539) (62541 . 62556) (62558 . 62566) (62568 . 62577) (62579 . 62586) (62588 . 62595) (62597 . 62608) (62610 . 62622) (62624 . 62645) (62647 . 62660) (62662 . 62677) (62679 . 62689) (62691 . 62696) (62698 . 62718) (62720 . 62729) (62730 . 62735) (62736 . 62749) (62751 . 62755) (62757 . 62765) (62766 . 62783) (62785 . 62800) (62802 . 62816) (62818 . 62826) (62827 . 62834) (62836 . 62845) (62847 . 62860) (62861 . 62878) (62880 . 62889) (62891 . 62892) (62894 . 62895) (62897 . 62910) (62912 . 62930) (62932 . 62941) (62942 . 62958) (62960 . 62966) (62968 . 62982) (62984 . 62995) (62996 . 63007) (63009 . 63017) (63019 . 63036) (63038 . 63044) (63046 . 63052) (63054 . 63061) (63063 . 63083) (63084 . 63118) (63120 . 63138) (63139 . 63159) (63161 . 63172) (63174 . 63192) (63194 . 63201) (63203 . 63215) (63217 . 63232) (63234 . 63250) (63251 . 63264) (63266 . 63285) (63286 . 63318) (63320 . 63332) (63334 . 63351) (63352 . 63380) (63382 . 63392) (63394 . 63409) (63410 . 63437) (63439 . 63454) (63456 . 63467) (63469 . 63484) (63486 . 63500) (63501 . 63530) (63532 . 63541) (63543 . 63560) (63561 . 63580) (63582 . 63590) (63592 . 63599) (63601 . 63606) (63608 . 63623) (63625 . 63638) (63639 . 63668) (63670 . 63685) (63687 . 63702) (63703 . 63709) (63711 . 63725) (63726 . 63749) (63751 . 63767) (63769 . 63772) (63774 . 63783) (63785 . 63798) (63800 . 63804) (63806 . 63825) (63826 . 63870) (63872 . 63916) (63918 . 63924) (63925 . 63927) (63929 . 63942) (63944 . 63956) (63958 . 63968) (63970 . 63981) (63983 . 64097) (64099 . 64110) (64112 . 64120) (64121 . 64160) (64161 . 64270) (64271 . 64275) (64276 . 64292) (64294 . 64322) (64324 . 64330) (64331 . 64403) (64405 . 64419) (64420 . 64438) (64440 . 64449) (64451 . 64511) (64512 . 64625) (64627 . 64631) (64633 . 64643) (64644 . 64873) (64875 . 64886) (64888 . 64900) (64901 . 65275) (65277 . 65287) (65289 . 65295) (65297 . 65303) (65305 . 65325) (65327 . 65329) (65331 . 65337) (65339 . 65352) (65354 . 65368) (65370 . 65384) (65386 . 65408) (65409 . 65575) (65577 . 65588) (65589 . 65601) (65603 . 65609) (65611 . 65630) (65632 . 65638) (65640 . 65644) (65646 . 65660) (65662 . 65670) (65672 . 65687) (65689 . 65699) (65700 . 65714) (65716 . 65720) (65722 . 65737) (65739 . 65756) (65758 . 65770) (65772 . 65784) (65786 . 65808) (65810 . 65824) (65826 . 65844) (65846 . 65860) (65862 . 65875) (65876 . 65886) (65888 . 65909) (65911 . 65917) (65918 . 65928) (65929 . 65935) (65937 . 65948) (65950 . 65955) (65957 . 65963) (65964 . 65967) (65968 . 65978) (65979 . 65980) (65982 . 65998) (66000 . 66008) (66010 . 66018) (66019 . 66025) (66027 . 66048) (66049 . 66064) (66066 . 66085) (66087 . 66099) (66101 . 66103) (66107 . 66108) (66110 . 66122) (66126 . 66128) (66130 . 66131) (66133 . 66144) (66146 . 66171) (66172 . 66185) (66187 . 66195) (66197 . 66208) (66210 . 66217) (66219 . 66246) (66247 . 66262) (66264 . 66268) (66270 . 66277) (66278 . 66293) (66295 . 66304) (66305 . 66330) (66332 . 66343) (66345 . 66353) (66354 . 66393) (66394 . 66452) (66454 . 66458) (66459 . 66521) (66522 . 66597) (66599 . 66612) (66614 . 66644) (66645 . 66673) (66674 . 66687) (66688 . 66692) (66693 . 66709) (66711 . 66739) (66741 . 66747) (66748 . 66752) (66754 . 66763) (66765 . 66767) (66769 . 66771) (66773 . 66778) (66780 . 66799) (66801 . 66813) (66815 . 66824) (66830 . 66834) (66836 . 66850) (66852 . 66869) (66871 . 66886) (66888 . 66906) (66908 . 66916) (66918 . 66925) (66927 . 66941) (66942 . 66950) (66952 . 66973) (66975 . 66979) (66981 . 66987) (66989 . 66992) (66994 . 67013) (67014 . 67016) (67018 . 67023) (67027 . 67032) (67036 . 67046) (67049 . 67057) (67059 . 67061) (67063 . 67095) (67097 . 67105) (67109 . 67114) (67118 . 67125) (67127 . 67129) (67131 . 67134) (67136 . 67138) (67143 . 67170) (67172 . 67189) (67191 . 67210) (67212 . 67214) (67216 . 67223) (67225 . 67245) (67246 . 67310) (67312 . 67330) (67332 . 67370) (67372 . 67389) (67391 . 67422) (67424 . 67428) (67429 . 67433) (67435 . 67459) (67461 . 67468) (67470 . 67481) (67482 . 67495) (67496 . 67510) (67511 . 67553) (67555 . 67562) (67563 . 67572) (67573 . 67605) (67607 . 67618) (67620 . 67632) (67633 . 67642) (67644 . 67651) (67652 . 67748) (67750 . 67776) (67778 . 67796) (67798 . 67813) (67814 . 67820) (67822 . 67837) (67839 . 67849) (67851 . 67853) (67855 . 67858) (67860 . 67865) (67867 . 67882) (67884 . 67891) (67893 . 67901) (67902 . 67917) (67919 . 67928) (67929 . 67985) (67987 . 67992) (67994 . 68001) (68002 . 68050) (68052 . 68062) (68063 . 68072) (68073 . 68087) (68089 . 68099) (68101 . 68107) (68109 . 68115) (68117 . 68137) (68139 . 68141) (68143 . 68149) (68151 . 68164) (68166 . 68180) (68182 . 68196) (68198 . 68220) (68221 . 68231) (68233 . 68242) (68244 . 68251) (68252 . 68260) (68262 . 68268) (68270 . 68275) (68277 . 68294) (68296 . 68325) (68327 . 68335) (68337 . 68339) (68341 . 68378) (68380 . 68388) (68390 . 68404) (68406 . 68448) (68450 . 68461) (68463 . 68474) (68476 . 68493) (68495 . 68518) (68519 . 68533) (68535 . 68537) (68539 . 68560) (68562 . 68570) (68571 . 68575) (68577 . 68585) (68587 . 68596) (68597 . 68615) (68617 . 68629) (68631 . 68636) (68638 . 68647) (68649 . 68671) (68673 . 68684) (68685 . 68699) (68701 . 68721) (68723 . 68734) (68735 . 68755) (68757 . 68771) (68773 . 68785) (68786 . 68807) (68809 . 68820) (68821 . 68828) (68830 . 68850) (68852 . 68854) (68856 . 68870) (68872 . 68881) (68882 . 68903) (68905 . 68919) (68921 . 68930) (68932 . 68940) (68942 . 68952) (68954 . 68976) (68978 . 68987) (68988 . 68994) (68996 . 69017) (69019 . 69035) (69036 . 69041) (69042 . 69045) (69047 . 69070) (69072 . 69086) (69088 . 69094) (69095 . 69109) (69111 . 69123) (69125 . 69140) (69142 . 69144) (69146 . 69153) (69155 . 69159) (69161 . 69171) (69173 . 69180) (69182 . 69193) (69194 . 69220) (69222 . 69228) (69230 . 69236) (69238 . 69240) (69242 . 69248) (69250 . 69265) (69267 . 69275) (69276 . 69286) (69288 . 69301) (69303 . 69319) (69321 . 69343) (69345 . 69349) (69351 . 69367) (69369 . 69391) (69393 . 69408) (69410 . 69422) (69424 . 69436) (69437 . 69452) (69454 . 69471) (69473 . 69475) (69477 . 69485) (69487 . 69497) (69499 . 69503) (69505 . 69515) (69516 . 69539) (69540 . 69564) (69566 . 69575) (69576 . 69592) (69594 . 69602) (69604 . 69618) (69619 . 69633) (69635 . 69648) (69650 . 69662) (69664 . 69670) (69672 . 69683) (69685 . 69704) (69706 . 69714) (69716 . 69725) (69727 . 69741) (69743 . 69749) (69750 . 69770) (69772 . 69796) (69797 . 69810) (69811 . 69815) (69816 . 69832) (69834 . 69862) (69864 . 69870) (69871 . 69886) (69887 . 69896) (69899 . 69902) (69904 . 69923) (69925 . 69935) (69936 . 69950) (69951 . 69967) (69969 . 69971) (69973 . 69995) (69997 . 70013) (70015 . 70025) (70027 . 70052) (70054 . 70061) (70063 . 70071) (70072 . 70085) (70086 . 70090) (70091 . 70107) (70109 . 70113) (70114 . 70119) (70121 . 70126) (70127 . 70148) (70150 . 70156) (70157 . 70167) (70169 . 70180) (70181 . 70213) (70215 . 70226) (70228 . 70240) (70241 . 70250) (70252 . 70276) (70278 . 70286) (70288 . 70299) (70301 . 70311) (70313 . 70329) (70331 . 70352) (70354 . 70363) (70365 . 70372) (70374 . 70380) (70381 . 70385) (70387 . 70397) (70399 . 70411) (70413 . 70415) (70417 . 70440) (70442 . 70450) (70451 . 70476) (70478 . 70490) (70492 . 70499) (70501 . 70512) (70514 . 70526) (70527 . 70531) (70533 . 70540) (70542 . 70562) (70566 . 70568) (70570 . 70587) (70588 . 70605) (70607 . 70633) (70634 . 70683) (70685 . 70698) (70700 . 70708) (70710 . 70724) (70726 . 70736) (70738 . 70749) (70750 . 70782) (70784 . 70797) (70799 . 70827) (70830 . 70847) (70850 . 70857) (70859 . 70912) (70914 . 70928) (70930 . 70943) (70944 . 70959) (70961 . 70972) (70974 . 70992) (70994 . 71013) (71014 . 71300) (71302 . 71320) (71322 . 71345) (71346 . 71730) (71731 . 72817) (72819 . 72834) (72836 . 72846) (72848 . 72857) (72859 . 72876) (72877 . 72893) (72895 . 72903) (72906 . 72909) (72911 . 72922) (72924 . 72935) (72937 . 72946) (72947 . 72953) (72955 . 72973) (72975 . 72990) (72992 . 73003) (73005 . 73009) (73011 . 73035) (73036 . 73078) (73081 . 73091) (73093 . 73117) (73119 . 73129) (73131 . 73137) (73138 . 73153) (73156 . 73158) (73160 . 73206) (73208 . 73227) (73229 . 73242) (73243 . 73251) (73252 . 73257) (73258 . 73275) (73277 . 73287) (73289 . 73298) (73299 . 73312) (73314 . 73334) (73335 . 73344) (73347 . 73366) (73368 . 73379) (73381 . 73406) (73408 . 73421) (73423 . 73440) (73442 . 73448) (73450 . 73463) (73465 . 73481) (73482 . 73499) (73501 . 73528) (73530 . 73542) (73544 . 73558) (73559 . 73575) (73577 . 73601) (73603 . 73621) (73623 . 73630) (73632 . 73642) (73644 . 73658) (73660 . 73662) (73664 . 73695) (73697 . 73715) (73717 . 73737) (73739 . 73759) (73761 . 73777) (73779 . 73791) (73792 . 73813) (73815 . 73823) (73825 . 73833) (73835 . 73851) (73853 . 73859) (73861 . 73872) (73874 . 73878) (73880 . 73892) (73894 . 73904) (73906 . 73915) (73916 . 73920) (73922 . 73929) (73931 . 73942) (73943 . 73947) (73949 . 73985) (73987 . 74001) (74003 . 74018) (74020 . 74033) (74035 . 74046) (74048 . 74055) (74057 . 74065) (74067 . 74079) (74080 . 74092) (74094 . 74109) (74111 . 74119) (74121 . 74125) (74127 . 74144) (74146 . 74164) (74166 . 74185) (74187 . 74199) (74201 . 74216) (74218 . 74230) (74232 . 74242) (74243 . 74906) (74908 . 74914) (74916 . 74932) (74934 . 74957) (74958 . 74997) (74999 . 75006) (75008 . 75019) (75021 . 75044) (75046 . 75058) (75060 . 75073) (75074 . 75078) (75080 . 75099) (75101 . 75115) (75117 . 75134) (75136 . 75147) (75149 . 75161) (75162 . 75179) (75181 . 75221) (75223 . 75236) (75238 . 75250) (75251 . 75277) (75279 . 75282) (75284 . 75287) (75289 . 75307) (75309 . 75313) (75315 . 75326) (75328 . 75341) (75343 . 75364) (75365 . 75368) (75370 . 75385) (75387 . 75404) (75406 . 75414) (75416 . 75438) (75440 . 75449) (75451 . 75460) (75462 . 75464) (75466 . 75478) (75480 . 75494) (75496 . 75505) (75507 . 75513) (75516 . 75525) (75527 . 75540) (75542 . 75552) (75553 . 75557) (75559 . 75582) (75584 . 75596) (75597 . 75601) (75603 . 75620) (75622 . 75632) (75633 . 75637) (75639 . 75664) (75665 . 75673) (75675 . 75680) (75682 . 75705) (75707 . 75720) (75722 . 75737) (75739 . 75748) (75749 . 75768) (75770 . 75779) (75781 . 75792) (75794 . 75807) (75809 . 75815) (75817 . 75834) (75836 . 75850) (75852 . 75856) (75858 . 75863) (75865 . 75873) (75875 . 75889) (75891 . 75895) (75897 . 75900) (75901 . 75914) (75916 . 75931) (75933 . 75935) (75939 . 75961) (75963 . 75967) (75969 . 75988) (75989 . 76011) (76013 . 76043) (76044 . 76055) (76057 . 76070) (76072 . 76084) (76086 . 76094) (76096 . 76119) (76121 . 76129) (76130 . 76137) (76140 . 76151) (76153 . 76164) (76166 . 76186) (76188 . 76201) (76203 . 76212) (76214 . 76216) (76218 . 76233) (76234 . 76263) (76265 . 76276) (76278 . 76290) (76291 . 76299) (76302 . 76314) (76316 . 76324) (76326 . 76338) (76340 . 76347) (76349 . 76353) (76355 . 76356) (76357 . 76374) (76376 . 76388) (76390 . 76392) (76396 . 76424) (76425 . 76439) (76440 . 76462) (76464 . 76488) (76490 . 76502) (76504 . 76518) (76520 . 76522) (76524 . 76535) (76537 . 76543) (76545 . 76565) (76566 . 76577) (76579 . 76606) (76607 . 76629) (76630 . 76643) (76645 . 76647) (76649 . 76665) (76667 . 76679) (76680 . 76711) (76713 . 76734) (76736 . 76751) (76753 . 76765) (76766 . 76782) (76784 . 76806) (76808 . 76817) (76818 . 76835) (76837 . 76848) (76849 . 76853) (76855 . 76879) (76881 . 76903) (76905 . 76909) (76911 . 76922) (76924 . 76936) (76937 . 76943) (76945 . 76951) (76953 . 76964) (76966 . 76978) (76980 . 77003) (77005 . 77029) (77031 . 77034) (77036 . 77056) (77058 . 77081) (77082 . 77098) (77100 . 77116) (77118 . 77123) (77125 . 77141) (77143 . 77150) (77152 . 77160) (77162 . 77179) (77181 . 77192) (77194 . 77211) (77212 . 77223) (77225 . 77229) (77231 . 77247) (77248 . 77261) (77263 . 77282) (77283 . 77296) (77298 . 77320) (77322 . 77333) (77335 . 77351) (77353 . 77365) (77367 . 77382) (77384 . 77398) (77400 . 77408) (77410 . 77418) (77420 . 77434) (77438 . 77450) (77452 . 77477) (77479 . 77496) (77498 . 77508) (77509 . 77521) (77523 . 77525) (77527 . 77534) (77536 . 77561) (77563 . 77567) (77569 . 77574) (77575 . 77600) (77602 . 77622) (77624 . 77638) (77640 . 77651) (77653 . 77658) (77660 . 77670) (77672 . 77681) (77683 . 77698) (77700 . 77714) (77715 . 77725) (77727 . 77731) (77733 . 77747) (77749 . 77762) (77764 . 77778) (77780 . 77817) (77818 . 77830) (77832 . 77840) (77842 . 77852) (77854 . 77866) (77868 . 77874) (77876 . 77882) (77884 . 77896) (77897 . 77913) (77915 . 77918) (77920 . 77929) (77931 . 77955) (77956 . 77968) (77970 . 77986) (77988 . 78005) (78006 . 78024) (78026 . 78036) (78038 . 78044) (78045 . 78051) (78052 . 78058) (78059 . 78076) (78077 . 78092) (78094 . 78097) (78099 . 78115) (78117 . 78130) (78131 . 78143) (78144 . 78153) (78155 . 78177) (78178 . 78208) (78210 . 78236) (78238 . 78247) (78249 . 78257) (78259 . 78265) (78267 . 78279) (78281 . 78287) (78289 . 78302) (78304 . 78306) (78308 . 78319) (78321 . 78323) (78325 . 78331) (78333 . 78346) (78348 . 78362) (78364 . 78384) (78386 . 78400) (78402 . 78414) (78416 . 78443) (78445 . 78460) (78461 . 78481) (78483 . 78495) (78497 . 78511) (78513 . 78525) (78527 . 78545) (78547 . 78562) (78564 . 78566) (78568 . 78593) (78595 . 78608) (78609 . 78616) (78617 . 78625) (78627 . 78644) (78646 . 78653) (78655 . 78661) (78663 . 78677) (78678 . 78692) (78694 . 78697) (78699 . 78703) (78705 . 78712) (78714 . 78728) (78730 . 78741) (78742 . 78748) (78750 . 78755) (78758 . 78765) (78766 . 78774) (78775 . 78783) (78785 . 78787) (78789 . 78805) (78806 . 78828) (78830 . 78854) (78856 . 78873) (78875 . 78896) (78898 . 78911) (78913 . 78923) (78925 . 78930) (78932 . 78945) (78946 . 78954) (78957 . 78969) (78971 . 78978) (78980 . 78986) (78988 . 79002) (79003 . 79009) (79014 . 79029) (79031 . 79044) (79046 . 79067) (79069 . 79084) (79086 . 79098) (79100 . 79114) (79115 . 79138) (79140 . 79150) (79152 . 79164) (79166 . 79176) (79178 . 79187) (79188 . 79203) (79205 . 79219) (79221 . 79225) (79227 . 79233) (79235 . 79243) (79245 . 79247) (79249 . 79255) (79257 . 79275) (79277 . 79298) (79300 . 79313) (79315 . 79332) (79334 . 79339) (79341 . 79348) (79349 . 79368) (79369 . 79393) (79395 . 79404) (79406 . 79411) (79413 . 79424) (79426 . 79435) (79437 . 79445) (79447 . 79455) (79457 . 79473) (79474 . 79498) (79500 . 79510) (79512 . 79527) (79528 . 79547) (79549 . 79565) (79567 . 79575) (79577 . 79592) (79594 . 79620) (79621 . 79646) (79648 . 79683) (79684 . 79723) (79725 . 79732) (79734 . 79741) (79743 . 79750) (79752 . 79770) (79772 . 79787) (79789 . 79798) (79799 . 79810) (79812 . 79820) (79824 . 79846) (79848 . 79874) (79876 . 79886) (79888 . 79897) (79898 . 79906) (79908 . 79918) (79920 . 79935) (79938 . 79950) (79952 . 79964) (79966 . 79983) (79985 . 80018) (80019 . 80036) (80040 . 80075) (80077 . 80085) (80087 . 80098) (80100 . 80102) (80104 . 80120) (80122 . 80138) (80140 . 80155) (80157 . 80167) (80169 . 80194) (80196 . 80206) (80207 . 80219) (80221 . 80251) (80253 . 80255) (80257 . 80273) (80274 . 80303) (80305 . 80319) (80320 . 80337) (80339 . 80353) (80355 . 80367) (80369 . 80380) (80382 . 80388) (80390 . 80401) (80402 . 80421) (80423 . 80439) (80441 . 80444) (80446 . 80453) (80455 . 80468) (80470 . 80485) (80487 . 80497) (80499 . 80509) (80511 . 80524) (80526 . 80536) (80538 . 80549) (80551 . 80562) (80564 . 80572) (80574 . 80590) (80591 . 80611) (80613 . 80615) (80617 . 80623) (80625 . 80637) (80639 . 80656) (80658 . 80660) (80662 . 80680) (80682 . 80700) (80701 . 80719) (80721 . 80734) (80736 . 80752) (80753 . 80767) (80768 . 80770) (80772 . 80778) (80780 . 80791) (80793 . 80802) (80805 . 80835) (80837 . 80843) (80845 . 80862) (80864 . 80874) (80876 . 80880) (80881 . 80885) (80886 . 80894) (80896 . 80913) (80915 . 80930) (80931 . 80962) (80964 . 80981) (80983 . 80990) (80992 . 81010) (81012 . 81022) (81023 . 81058) (81060 . 81064) (81066 . 81088) (81090 . 81112) (81114 . 81132) (81134 . 81136) (81138 . 81154) (81156 . 81173) (81175 . 81187) (81189 . 81206) (81208 . 81220) (81221 . 81236) (81238 . 81260) (81262 . 81285) (81287 . 81308) (81310 . 81327) (81328 . 81358) (81360 . 81378) (81380 . 81384) (81386 . 81399) (81401 . 81411) (81413 . 81434) (81436 . 81440) (81442 . 81444) (81446 . 81450) (81452 . 81457) (81459 . 81462) (81464 . 81473) (81477 . 81488) (81490 . 81519) (81521 . 81536) (81537 . 81543) (81545 . 81566) (81568 . 81575) (81577 . 81597) (81599 . 81611) (81612 . 81617) (81618 . 81621) (81622 . 81636) (81638 . 81659) (81661 . 81671) (81672 . 81693) (81694 . 81698) (81700 . 81706) (81708 . 81737) (81739 . 81750) (81751 . 81776) (81778 . 81798) (81800 . 81814) (81816 . 81818) (81820 . 81843) (81845 . 81861) (81862 . 81880) (81881 . 81883) (81884 . 81892) (81894 . 81928) (81929 . 81933) (81935 . 81943) (81945 . 81966) (81967 . 81979) (81980 . 81991) (81993 . 81996) (81998 . 82008) (82009 . 82021) (82023 . 82049) (82051 . 82065) (82067 . 82074) (82076 . 82100) (82102 . 82135) (82136 . 82162) (82164 . 82175) (82177 . 82199) (82201 . 82209) (82211 . 82234) (82236 . 82248) (82250 . 82286) (82288 . 82292) (82294 . 82314) (82316 . 82322) (82323 . 82326) (82327 . 82348) (82349 . 82381) (82383 . 82389) (82391 . 82419) (82421 . 82425) (82427 . 82438) (82440 . 82442) (82444 . 82470) (82471 . 82488) (82490 . 82502) (82504 . 82519) (82521 . 82530) (82532 . 82544) (82546 . 82564) (82566 . 82591) (82593 . 82598) (82600 . 82624) (82626 . 82638) (82642 . 82649) (82650 . 82656) (82659 . 82664) (82666 . 82694) (82696 . 82717) (82719 . 82733) (82735 . 82749) (82751 . 82764) (82766 . 82792) (82793 . 82808) (82810 . 82819) (82821 . 82829) (82831 . 82847) (82848 . 82888) (82889 . 82917) (82919 . 82950) (82951 . 82983) (82984 . 83006) (83008 . 83022) (83024 . 83041) (83043 . 83056) (83057 . 83090) (83092 . 83099) (83101 . 83103) (83105 . 83107) (83109 . 83130) (83132 . 83147) (83148 . 83176) (83178 . 83202) (83204 . 83208) (83210 . 83213) (83215 . 83224) (83226 . 83243) (83245 . 83264) (83265 . 83285) (83287 . 83301) (83303 . 83315) (83317 . 83337) (83339 . 83351) (83353 . 83364) (83366 . 83376) (83378 . 83394) (83395 . 83415) (83417 . 83424) (83425 . 83428) (83429 . 83457) (83459 . 83477) (83478 . 83499) (83501 . 83542) (83544 . 83554) (83556 . 83566) (83567 . 83575) (83576 . 83586) (83589 . 83610) (83612 . 83629) (83631 . 83646) (83648 . 83652) (83654 . 83680) (83682 . 83684) (83685 . 83703) (83705 . 83721) (83722 . 83738) (83739 . 83753) (83755 . 83773) (83774 . 83788) (83790 . 83816) (83817 . 83821) (83823 . 83845) (83847 . 83859) (83861 . 83873) (83875 . 83883) (83885 . 83895) (83897 . 83908) (83910 . 83918) (83920 . 83945) (83947 . 83961) (83962 . 83971) (83973 . 83976) (83978 . 83997) (83999 . 84007) (84009 . 84017) (84019 . 84027) (84029 . 84039) (84040 . 84070) (84072 . 84090) (84092 . 84114) (84116 . 84118) (84120 . 84150) (84152 . 84171) (84173 . 84198) (84200 . 84202) (84204 . 84215) (84217 . 84243) (84245 . 84261) (84263 . 84289) (84291 . 84304) (84306 . 84308) (84310 . 84337) (84339 . 84351) (84353 . 84366) (84368 . 84381) (84382 . 84395) (84397 . 84408) (84410 . 84418) (84420 . 84432) (84434 . 84457) (84458 . 84464) (84466 . 84484) (84486 . 84498) (84500 . 84516) (84518 . 84524) (84526 . 84546) (84547 . 84553) (84555 . 84569) (84570 . 84571))
:END:

* clean code & design

*(本文档是 Robert "Uncle Bob" Martin 和 John Ousterhout 在 2024 年 9 月至 2025 年 2 月期间进行的一系列讨论(部分在线上, 部分面对面)的结果. 如果您想对本文档中的任何内容发表评论, 我们建议您在[与 APOSD 相关的 Google 论坛](https://groups.google.com/g/software-design-book) 上进行). /

** 介绍

*JOHN:*

嗨, Bob(Uncle Bob)! 你和我都写过关于软件设计的书. 我们在某些方面意见一致, 但在我最近的书<软件设计的哲学>(以下简称" APOSD" )和你经典的书<Clean Code>之间存在一些相当大的意见分歧. 感谢你同意在这里讨论这些分歧.

*UB:*

很高兴, John. 在我们开始之前, 我想说我仔细阅读了你的书, 我觉得它非常有趣, 而且充满了宝贵的见解. 有些地方我不同意你的观点, 比如 TDD 和抽象优先的增量主义, 但总的来说, 我非常喜欢它.

*JOHN:*

我想和你讨论三个主题: 方法长度, 注释和测试驱动开发. 但在深入讨论这些问题之前, 让我们先比较一下总体理念. 当你听到一个与软件设计相关的新想法时, 你如何决定是否支持这个想法?

我先说. 对我来说, 软件设计的根本目标是使系统易于理解和修改. 我使用" 复杂性" 一词来指代使系统难以理解和修改的事物. 导致复杂性的最重要因素与信息有关:

-   开发人员为了完成一项任务, 头脑中必须掌握多少信息?
-   开发人员所需的信息的可访问性和显而易见性如何?

开发人员需要掌握的信息越多, 他们就越难在系统上工作. 如果所需的信息不明显, 情况会更糟. 最糟糕的情况是, 当一个关键信息隐藏在开发人员从未听说过的某个遥远的代码片段中.

当我评估一个与软件设计相关的想法时, 我会问它是否会降低复杂性. 这通常意味着要么减少开发人员必须知道的信息量, 要么使所需的信息更明显.

现在轮到你了: 当你决定支持哪些想法时, 是否有你使用的通用原则?

*UB:*

我同意你的方法. 一种规范或技术应该使程序员的工作更容易. 我要补充一点, 我们最想帮助的程序员不是作者. 我们希望让其工作更轻松的程序员是必须阅读和理解他人(或一周后他们自己)编写的代码的程序员. 程序员花在阅读代码上的时间远多于编写代码, 所以我们希望简化的是阅读活动.

** 方法长度

*JOHN:*

我们第一个分歧领域是方法长度.
在<Clean Code>的第 34 页, 你说" 函数的首要规则是它们应该很小. 函数的第二条规则是它们*应该比这更小/. "  稍后, 你说" 函数几乎不应该超过 20 行" , 并建议函数应该" 只有两行, 三行或四行长" . 在第 35 页, 你说" =if= 语句, =else= 语句, =while= 语句等中的块应该只有一行长. 这一行可能应该是一个函数调用. " 我在<Clean Code>中找不到任何暗示函数可能太短的内容.

我同意将代码划分为相对较小的单元(" 模块化设计" )是减少程序员一次必须牢记的信息量的最重要方法之一. 当然, 这个想法是将一个复杂的功能块封装在一个具有简单接口的单独方法中. 然后, 开发人员可以利用该方法的功能(或阅读调用该方法的代码), 而无需学习该方法实现的细节; 他们只需要学习它的接口. 最好的方法是那些提供大量功能但具有非常简单接口的方法: 它们用更小的认知负荷(学习接口)取代了大的认知负荷(阅读详细的实现). 我称这些方法为" 深层" 方法.

然而, 像软件设计中的大多数想法一样, 分解可能会走得太远.
随着方法越来越小, 进一步细分的好处越来越少.
隐藏在每个接口后面的功能量下降, 而接口通常变得更加复杂.
我称这些接口为" 浅层" : 它们在减少程序员需要知道的内容方面没有太大帮助. 最终, 达到了使用该方法的人需要了解其实现的各个方面的地步. 这样的方法通常毫无意义.

过度分解的另一个问题是它往往会导致*纠缠/. 如果两个方法, 为了理解其中一个方法在内部是如何工作的, 你还需要阅读另一个方法的代码, 那么这两个方法是纠缠的(或在 APOSD 术语中是" 连接的" ). 如果你曾经发现自己在阅读代码时在两个方法的实现之间来回切换, 这是一个危险信号, 表明这些方法可能纠缠在一起. 纠缠的方法很难阅读, 因为你需要同时掌握的信息并不都在同一个地方. 纠缠的方法通常可以通过组合它们来改进, 以便所有代码都在一个地方.

<Clean Code>中关于方法长度的建议非常极端, 它鼓励程序员创建同时遭受浅层接口和纠缠的微小方法. 在方法中设置任意数字限制(例如 2-4 行)以及在 =if= 或 =while= 语句的主体中设置单行会加剧此问题.

*UB:*

虽然我强烈建议使用非常短的函数, 但我认为说这本书设置了任意的数字限制是不公平的. 你在第 34 页提到的 2-4 行函数是 Kent Beck 和我在 1999 年作为学习 TDD 的练习一起编写的 _Sparkle_ applet 的一部分.

我认为值得注意的是, 该 applet 中的大多数函数都是 2-4 行长, 因为它是一个 Swing 程序; 而 Swing 程序往往有非常长的方法.

至于设置限制, 在第 13 页, 我明确表示, 尽管书中的建议对我和其他作者来说效果很好, 但它们可能并不适合所有人. 我没有声称拥有最终权威, 甚至没有声称拥有绝对的"正确性". 它们仅供参考.

*JOHN:*

我认为如果我们查看具体的代码示例, 这些问题将最容易理解. 但在我们这样做之前, 让我问你, Bob: 你是否相信代码可能过度分解, 或者更小总是更好? 而且, 如果你认为过度分解是可能的, 你如何识别它何时发生?

*UB:*

代码当然有可能过度分解. 这是一个例子:

        void doSomething() {doTheThing()} // 过度分解.

我用来决定分解的程度的策略是旧规则, 即一个方法应该做" /一件事/" . 如果我可以*有意义地*从另一个方法中提取一个方法, 那么原始方法做了不止一件事. "有意义地" 意味着可以给提取的功能一个描述性的名称;
并且它比原始方法做得少.

*JOHN:*

不幸的是, "一件事 "的方法会导致过度分解:

 1. " 一件事" 这个术语含糊不清, 容易被滥用. 例如, 如果一个方法有两行代码, 它不是在做两件事吗?

 2. 你没有提供任何有用的护栏来防止过度分解. 你给出的例子太极端, 没有用处, 而" 可以命名吗" 的限定条件也无济于事: 任何东西都可以命名.

 3. 在许多情况下, "一件事 "的方法是完全错误的. 如果两件事密切相关, 那么在同一个方法中实现它们很可能是有意义的. 例如, 任何线程安全的方法都必须首先获取锁, 然后执行其功能. 这是两件"事" , 但它们属于同一个方法.

*UB:*

让我先解决最后一件事. 你建议锁定线程和执行临界区应该在同一个方法中. 但是, 我倾向于将锁定与临界区分开.

        void concurrentOperation() {
                lock()
                criticalSection();
                unlock()
        }

这会将临界区与锁分离, 并允许在不需要锁定时(例如, 在单线程模式下)或当其他人已经设置了锁定时调用它.

现在, 关于" 滥用易用性" 的论点. 我不认为这是一个重大问题. =If= 语句很容易被滥用. =Switch= 语句很容易被滥用. 赋值语句很容易被滥用. 某事容易被滥用的事实并不意味着应该避免或抑制它. 这仅仅意味着人们应该采取适当的谨慎态度. 总会有这个东西叫做: _判断力_.

因此, 当面对较大方法中的这段代码片段时:

        ...
        amountOwed=0;
        totalPoints=0;
        ...

将其提取如下是不明智的, 因为提取没有意义. 实现并不比接口更详细.

        void clearAmountOwed() {
          amountOwed=0;
        }

        void clearTotalPoints() {
          totalPoints=0;
        }

但是, 将其提取如下可能是明智的, 因为接口是抽象的, 而实现具有更深的细节.

        void clearTotals() {
                amountOwed=0;
                totalPoints=0;
        }

后者有一个很好的描述性名称, 它足够抽象, 以至于有意义而不冗余. 这两行紧密相关, 因此有资格做_一件事_: 初始化.

*JOHN:*

当然, 任何东西都可能被滥用. 但最好的设计方法是鼓励人们以正确的方式做事, 并阻止滥用. 不幸的是, "一件事 "规则鼓励滥用, 原因如上所述.

当然, 软件设计师需要运用判断力: 不可能为软件设计提供精确的配方.
但是, 良好的判断力需要原则和指导. <Clean Code>中关于分解的论点, 包括 "一件事 "规则, 是片面的. 它们给出了关于何时分解事物的强有力的, 具体的, 定量的建议, 但几乎没有关于如何判断你是否走得太远的指导. 我能找到的只是第 36 页关于清单 3-3 的一个两句话的例子(这非常微不足道), 埋藏在" 砍, 砍, 砍" 的劝告中.

我使用深/浅特征的原因之一是它捕捉了权衡的两个方面; 它会告诉你分解何时是好的, 以及分解何时会使事情变得更糟.

*UB:*

你说得很好, 我在书中没有太多谈论如何做出判断. 早在 2008 年, 我关心的是打破网络早期非常大的函数的习惯. 在第二版中, 我更加平衡了.

尽管如此, 如果我必须犯错, 我宁愿在分解方面犯错. 考虑和可视化分解是有价值的. 如果我们认为它们走得太远, 它们总是可以内联的.

*JOHN:*

回到你的 =clearTotals= 例子:

-   =clearTotals= 方法似乎与 "一件事 "规则相矛盾: 变量 =amountOwed= 和 =totalPoints= 似乎没有特别的关系, 所以将它们都初始化是在做两件事, 不是吗? 你说这两个语句都在执行初始化, 这使得它只是一件事(初始化). 这是否意味着也可以有一个方法来初始化两个完全独立的对象, 它们之间没有任何共同点? 我怀疑不是. 感觉你正在努力创建一个干净的框架来应用 "一件事 "规则; 这让我认为这不是一个好规则.
-   在没有看到更多上下文的情况下, 我怀疑 =clearTotals= 方法是否有意义.

*UB:*

我希望你同意在这两个例子中, 前者更好一点.

        public String makeStatement() {
          clearTotals();
          return makeHeader() + makeRentalDetails() + makeFooter();
        }

---

        public String makeStatement() {
      amountOwed=0;
      totalPoints=0;
      return makeHeader() + makeRentalDetails() + makeFooter();
        }

*JOHN:*

嗯, 实际上, 不是. 第二个例子完全清晰明了: 我看不出把它分开有什么好处.

*SPOCK (a.k.a UB):*

引人入胜.

*JOHN:*

我认为, 如果我们考虑一个重要的代码示例, 将更容易澄清我们的分歧. 让我们看看<Clean Code>中的 =PrimeGenerator= 类, 它是第 145-146 页的清单 10-8. 这个 Java 类生成前 N 个素数:

        package literatePrimes;

        import java.util.ArrayList;

        public class PrimeGenerator {
          private static int[] primes;
          private static ArrayList<Integer> multiplesOfPrimeFactors;

          protected static int[] generate(int n) {
            primes = new int[n];
            multiplesOfPrimeFactors = new ArrayList<Integer>();
            set2AsFirstPrime();
            checkOddNumbersForSubsequentPrimes();
            return primes;
          }

          private static void set2AsFirstPrime() {
            primes[0] = 2;
            multiplesOfPrimeFactors.add(2);
          }

          private static void checkOddNumbersForSubsequentPrimes() {
            int primeIndex = 1;
            for (int candidate = 3;
                 primeIndex < primes.length;
                 candidate += 2) {
              if (isPrime(candidate))
                primes[primeIndex++] = candidate;
            }
          }

          private static boolean isPrime(int candidate) {
            if (isLeastRelevantMultipleOfLargerPrimeFactor(candidate)) {
              multiplesOfPrimeFactors.add(candidate);
              return false;
            }
            return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
          }

          private static boolean
          isLeastRelevantMultipleOfLargerPrimeFactor(int candidate) {
            int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
            int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
            return candidate == leastRelevantMultiple;
          }

          private static boolean
          isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
            for (int n = 1; n < multiplesOfPrimeFactors.size(); n++) {
              if (isMultipleOfNthPrimeFactor(candidate, n))
                return false;
            }
            return true;
          }

          private static boolean
          isMultipleOfNthPrimeFactor(int candidate, int n) {
            return candidate ==
              smallestOddNthMultipleNotLessThanCandidate(candidate, n);
          }

          private static int
          smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
            int multiple = multiplesOfPrimeFactors.get(n);
            while (multiple < candidate)
              multiple += 2 * primes[n];
            multiplesOfPrimeFactors.set(n, multiple);
            return multiple;
          }
        }

在我们深入研究这段代码之前, 我鼓励每个阅读本文的人花时间阅读代码并得出自己的结论. 你觉得代码容易理解吗? 如果是, 为什么? 如果不是, 是什么让它变得复杂?

另外, Bob, 你能确认你支持这段代码吗(即代码是否正确地体现了<Clean Code>的设计理念, 以及你是否认为如果代码在生产中使用, 它应该以这种方式出现)?

*UB:*

啊, 是的. =PrimeGenerator=. 这段代码来自 1982 年 Donald Knuth 撰写的关于[/Literate Programming/](https://www.cs.tufts.edu/~nr/cs257/archive/literate-programming/01-knuth-lp.pdf) 的论文. 该程序最初是用 Pascal 编写的, 并由 Knuth 的 WEB 系统自动生成为一个非常大的方法, 我将其翻译成 Java.

当然, 这段代码从未用于生产. Knuth 和我都把它作为一个教学例子. 在<Clean Code>中, 它出现在名为*Classes*的章节中. 本章的教训是, 一个非常大的方法通常包含许多不同的代码段, 最好将它们分解为独立的类.

在本章中, 我从该函数中提取了三个类: =PrimePrinter=, =RowColumnPagePrinter= 和 =PrimeGenerator=.

其中一个提取的类是 =PrimeGenerator=. 它具有以下代码(我没有在书中发布). 变量名和整体结构是 Knuth 的.

        public class PrimeGenerator {
          protected static int[] generate(int n) {
            int[] p = new int[n];
            ArrayList<Integer> mult = new ArrayList<Integer>();
            p[0] = 2;
            mult.add(2);
            int k = 1;
            for (int j = 3; k < p.length; j += 2) {
              boolean jprime = false;
              int ord = mult.size();
              int square = p[ord] * p[ord];
              if (j == square) {
                mult.add(j);
              } else {
                jprime=true;
                for (int mi = 1; mi < ord; mi++) {
                  int m = mult.get(mi);
                  while (m < j)
                    m += 2 * p[mi];
                  mult.set(mi, m);
                  if (j == m) {
                    jprime = false;
                    break;
                  }
                }
              }
              if (jprime)
                p[k++] = j;
            }
            return p;
          }
        }

即使我已经完成了本章的课程, 我也不想让那个方法看起来如此过时. 所以作为事后补充, 我稍微清理了一下. 我的目标不是描述如何生成素数. 我希望我的读者看到违反单一职责原则的大方法如何分解为几个较小的, 名称良好的类, 其中包含几个较小的, 名称良好的方法.

*JOHN:*

感谢你的背景介绍. 即使该代码的细节不是本章的重点, 但假设该代码代表了你认为的" 正确" 和" 最干净" 的做事方式, 给定了手头的算法. 这就是我不同意的地方.

=PrimeGenerator= 存在许多设计问题, 但现在我将重点关注方法长度. 代码被分解得太多(8 个微小的方法), 以至于难以阅读. 首先, 考虑 =isNotMultipleOfAnyPreviousPrimeFactor= 方法. 此方法调用 =isMultipleOfNthPrimeFactor=, 后者调用 =smallestOddNthMultipleNotLessThanCandidate=. 这些方法是浅层的和纠缠的: 为了理解 =isNot...=, 你必须阅读其他两个方法并将所有代码一次加载到你的脑海中. 例如, =isNot...= 有副作用(它修改 =multiplesOfPrimeFactors=), 但除非你阅读所有三个方法, 否则你无法看到这一点.

*UB:*

我认为你有道理. 十八年前, 当我进行这种重构时, 名称和结构对我来说非常有意义. 它们现在对我来说也很有意义--但那是因为我再次理解了算法. 几天前, 当我第一次回到算法时, 我与名称和结构作斗争. 一旦我理解了算法, 名称和结构就非常有意义了.

*JOHN:*

即使对于理解算法的人来说, 这些名称也是有问题的; 稍后, 在讨论注释时, 我们将讨论它们. 而且, 如果代码在作者稍后返回代码时不再有意义, 这意味着代码有问题. 代码最终可以被理解(伴随着巨大的痛苦)这一事实并不能成为其纠缠的借口.

*UB:*

如果我们有这样一个水晶球, 我们可以帮助我们未来的自己避免这种" _巨大的痛苦_" . ;-)

*JOHN:*

不需要水晶球. =PrimeGenerator= 的问题非常明显, 例如纠缠和接口复杂性; 也许你对它难以理解感到惊讶, 但我没有. 换句话说, 如果你无法预测你的代码是否容易理解, 那么你的设计方法就有问题.

*UB:*

够公平. 然而, 我会说, 我解释你的重写(如下)时也有同样的" _痛苦_" . 因此, 显然, 我们两种方法都不足以将我们的读者从这种挣扎中拯救出来.

*JOHN:*

回到我关于复杂性的介绍性评论, 将 =isNot...= 分成三个方法并没有减少你必须牢记的信息量. 它只是将其分散开来, 因此你需要一起阅读所有三个方法并不那么明显. 而且, 由于代码被分解, 因此很难看到代码的整体结构: 读者必须在方法之间来回切换, 实际上是在他们的脑海中重建一个整体版本. 因为这些部分都是相关的, 所以如果将所有代码放在一个地方, 这段代码将最容易理解.

*UB:*

我不同意. 这是 =isNotMultipleOfAnyPreviousPrimeFactor=.

          private static boolean
          isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
            for (int n = 1; n < multiplesOfPrimeFactors.size(); n++) {
              if (isMultipleOfNthPrimeFactor(candidate, n))
                return false;
            }
            return true;
          }

如果你信任 =isMultipleOfNthPrimeFactor= 方法, 那么这个方法本身就很好. 我的意思是, 我们循环遍历所有 n 个先前的素数, 看看候选数是否是倍数. 这非常简单明了.

现在, 问一下我们如何确定候选数是否是倍数是公平的, 在这种情况下, 你会想检查 =isMultiple...= 方法.

*JOHN:*

这段代码看起来确实简单明了.
不幸的是, 这种表象具有欺骗性.
如果读者相信名称 =isMultipleOfNthPrimeFactor=(这表明一个没有副作用的谓词)并且不费心阅读其代码, 他们将不会意识到它有副作用, 并且这些副作用对 =isNot...= 的 =candidate= 参数创建了一个约束(它必须从调用到调用单调不减). 要理解这些行为, 你必须同时阅读 =isMultiple...= 和 =smallestOdd...=. 当前的分解向读者隐藏了这些重要信息.

如果有一件事比不理解代码更容易导致错误, 那就是认为你理解了它而实际上你不理解.

*UB:*

这是一个有效的担忧. 然而, 由于函数按调用顺序呈现, 因此这一点得到了缓和. 因此, 我们可以预期读者已经看到了主循环并理解 =candidate= 每次迭代增加 2.

隐藏在 =smallestOddNth...= 中的副作用有点问题. 既然你指出了它, 我就不太喜欢它了. 尽管如此, 该副作用不应混淆对 =isNot...= 的基本理解.

一般来说, 如果你信任被调用方法的名称, 那么理解调用者不需要理解被调用者. 例如:

        for (Employee e : employees)
          if (e.shouldPayToday())
                  e.pay();

如果我们用它们的实现替换这两个方法调用, 这不会变得更容易理解. 这样的替换只会掩盖意图.

*JOHN:*

这个例子有效, 因为被调用方法与父方法相对独立. 不幸的是, =isNot...= 不是这种情况.

事实上, =isNot...= 不仅与它调用的方法纠缠在一起, 而且还与它的调用者纠缠在一起. =isNot...= 只有在循环中调用时才有效, 其中 =candidate= 单调递增. 为了让自己相信它有效, 你必须找到调用 =isNot...= 的代码并确保 =candidate= 从一次调用到下一次调用永远不会减少. 将 =isNot...= 与调用它的循环分开会使读者更难相信它有效.

*UB:*

正如我之前所说, 这就是方法排序方式的原因. 我希望当你到达 =isNot...= 时, 你已经阅读了 =checkOddNumbersForSubsequentPrimes= 并且知道 =candidate= 每次增加 2.

*JOHN:*

让我们简要讨论一下这一点, 因为这是我与<Clean Code>意见不同的另一个领域. 如果方法纠缠在一起, 那么方法的定义就没有聪明的排序可以解决问题.

在这种特定情况下, 在 =checkOdd...= 中的循环和 =isNot...= 之间插入了另外两个方法, 因此读者在到达 =isNot...= 之前会忘记循环上下文. 此外, 实际创建对循环的依赖的代码不在 =isNot...= 中: 它在 =smallestOdd...= 中, 它甚至更远离 =checkOdd...=.

*UB:*

我真诚地怀疑有人会忘记 =candidate= 每次增加 2. 这是一种避免浪费的非常明显的方法.

*JOHN:*

在我的开场白中, 我谈到了减少人们必须同时牢记的信息量是多么重要. 在这种情况下, 读者必须记住那个循环, 同时他们阅读四个插入的方法, 这些方法与循环基本无关. 你显然认为这将很容易和自然(我不同意). 但情况甚至更糟. 没有任何迹象表明 =checkOdd...= 的哪些部分稍后会很重要, 因此唯一安全的方法是记住*所有内容/, 从*每个*方法中, 直到你遇到可能从它派生的每个其他方法. 而且, 为了连接这些部分, 读者还必须重建调用图才能注意到, 即使通过 4 层方法调用, =smallestOdd...= 中的代码也会对 =checkOdd...= 中的循环施加约束. 这对读者来说是​​一个不合理的认知负担.

如果两段代码紧密相关, 那么解决方案是将它们放在一起. 分离这些部分, 即使在物理上相邻的方法中, 也会使代码更难理解.

对我来说, =PrimeGenerator= 中的所有方法都是纠缠的: 为了理解该类, 我必须将所有方法一次加载到我的脑海中. 当我阅读代码时, 我不断地在方法之间来回切换. 这是一个危险信号, 表明代码已过度分解.

Bob, 你能帮我理解一下你为什么将代码分成这么小的方法吗?
我是否错过了拥有这么多方法的好处?

*UB:*

我想你和我只是在这方面意见不一致. 总的来说, 我相信小型, 名称良好的方法和关注点分离的原则. 一般来说, 如果你可以将一个大方法分解为几个名称良好的较小方法, 这些方法具有不同的关注点, 并且这样做可以暴露它们的接口和高级功能分解, 那么这是一件好事.

-   循环遍历奇数是一种关注点.
-   确定素数是另一种关注点.
-   标记素数的倍数是另一种关注点.

在我看来, 分离和命名这些关注点有助于揭示算法的工作方式--即使以一些纠缠为代价.

在你的解决方案中(我们很快就会在下面看到), 你以类似的方式分解了算法. 但是, 你没有将关注点分离到函数中, 而是将它们分离到带有注释的部分中.

你提到在我的解决方案中, 读者在阅读其他函数时必须牢记循环上下文. 我建议在你的解决方案中, 读者在阅读你的解释性注释时必须牢记循环上下文. 他们可能必须在各部分之间" 来回切换" 才能建立他们的理解.

现在, 也许你担心在我的解决方案中, " 翻转" 的距离(以行为单位)比你的解决方案中更长. 我不确定这是不是一个重要的点, 因为它们都适合同一个屏幕(至少它们在我的屏幕上是这样), 而且地标非常明显.

*** 方法长度总结

*JOHN:*

听起来是时候结束这一部分了. 这是我们达成共识和分歧的合理总结吗?

-   我们都同意模块化设计是一件好事.

-   我们都同意有可能过度分解, 并且<Clean Code 第 1 版>没有提供太多关于如何识别过度分解的指导.

-   我们不同意分解的程度: 你建议将代码分解成比我建议的更小的单元. 你认为你建议的额外分解使代码更容易理解; 我认为它走得太远, 实际上使代码更难理解.

-   你认为 " 一件事"  规则, 在运用判断力的情况下, 将导致适当的分解. 我认为它缺乏护栏, 将导致过度分解.

-   我们都同意 =PrimeGenerator= 内部方法分解是有问题的. 你指出, 你编写 =PrimeGenerator= 的主要目标是展示如何分解为类, 而不是如何将类内部分解为方法.

-   类中方法之间的纠缠对你的困扰不如对我困扰. 你认为分解方法的好处可以弥补纠缠引起的问题. 我认为它们不能: 当分解的方法纠缠在一起时, 它们比没有分解时更难阅读, 这违背了分解的全部目的.

-   你认为对类中的方法进行排序可以帮助弥补方法之间的纠缠; 我不同意.

*UB:*

我认为这是对我们协议和分歧的公平评估. 我们都重视分解, 我们都避免纠缠; 但我们对这两个价值观的相对权重有分歧.

** 注释

*JOHN:*

让我们继续讨论第二个分歧领域: 注释. 在我看来, <Clean Code>中的注释方法导致代码文档不足, 这增加了软件开发的成本. 我肯定你不同意, 所以让我们讨论一下.

以下是<Clean Code>中关于注释的说法(第 54 页):

> 注释的正确使用是为了弥补我们在代码中表达自己的失败. 请注意, 我使用了" 失败" 这个词. 我是认真的. 注释总是失败. 我们必须有它们, 因为我们不能总是弄清楚如何在没有它们的情况下表达自己, 但它们的使用并不是庆祝的理由......每次你写注释时, 你都应该做鬼脸, 并感受到你表达能力的失败.

我必须诚实: 当我第一次读到这段文字时, 我感到震惊, 它仍然让我畏缩. 这污名化了写注释. 初级开发人员会想" 如果我写注释, 人们可能会认为我失败了, 所以最安全的事情是不写注释. "

*UB:*

那一章以以下文字开头:
>/没有什么能比得上一个恰到好处的注释那么有帮助了. /

它接着说注释是*必要的*恶.

读者推断他们不应该写注释的唯一方法是他们实际上没有阅读这一章. 本章介绍了一系列注释, 有些不好, 有些好.

*JOHN:*

<Clean Code>更关注注释的" 邪恶" 方面, 而不是" 必要" 方面. 你上面引用的句子后面有两个句子批评注释. 第 4 章花了 4 页谈论好的注释, 然后是 15 页谈论坏的注释. 有一些冷落, 比如" 唯一真正好的注释是你找到一种不写的方法" . 而且" 注释总是失败" 这句话朗朗上口, 以至于它是读者最有可能从本章中记住的一件事.

*UB:*

页数差异是因为编写好的注释只有几种方法, 而编写坏注释的方法要多得多.

*JOHN:*

我不同意; 这说明了你对注释的偏见. 如果你看看 APOSD 的第 13 章, 它会发现比<Clean Code>更有建设性的使用注释的方法. 如果你比较 APOSD 第 13 章和<Clean Code>第 4 章的语气, <Clean Code>对注释的敌意就变得非常明显了.

*UB:*

我将让你用_Comments_章节中的初始陈述和最终示例来平衡最后一条评论. 它们并没有传达" 敌意" .

我并不反对一般的注释. 我_非常_反对无端的注释.

你和我可能都经历过注释绝对必要的时期. 在 70 年代和 80 年代, 我是一名汇编语言程序员. 我还写了一点 FORTRAN. 那些没有注释的语言程序是不可理解的.

因此, 默认情况下编写注释成为传统智慧. 事实上, 计算机科学专业的学生被教导要不加批判地编写注释. 注释变成了_纯粹的好事_.

在<Clean Code>中, 我决定与这种心态作斗争. 注释可能_非常糟糕_, 也可能很好.

*JOHN:*

我不同意注释在今天比 40 年前更不必要.

注释至关重要, 并为软件增加了巨大的价值. 问题是有很多重要信息根本无法用代码表达. 通过添加注释来填补这些缺失的信息, 开发人员可以使代码更易于阅读. 正如你所说, 这不是" 他们表达能力的失败" .

*UB:*

有些重要信息没有或不能用代码表达, 这是非常正确的. 这是一个失败. 我们语言的失败, 或者我们使用它们来表达自己的能力的失败. 在任何情况下, 注释都是我们使用语言来表达意图的失败.

我们经常失败, 因此注释是必要的恶--或者, 如果你愿意, 是_不幸的必要_. 如果我们拥有完美的编程语言(TM), 我们将永远不会再写注释.

*JOHN:*

我不同意完美的编程语言会消除对注释的需求. 注释和代码服务于非常不同的目的, 所以对我来说, 我们应该对两者使用相同的语言并不明显. 根据我的经验, 英语作为注释语言效果很好. 你为什么认为关于程序的信息应该完全用代码表达, 而不是使用代码和英语的组合?

*UB:*

我感到遗憾的是, 我们有时必须使用人类语言而不是编程语言. 人类语言不精确, 充满歧义. 使用人类语言来描述像程序一样精确的东西非常困难, 并且充满了许多错误和无意中提供错误信息的机会.

*JOHN:*

我同意英语并不总是像代码那样精确, 但它仍然可以以精确的方式使用, 并且注释通常不需要与代码相同的精度. 注释通常包含定性信息, 例如*为什么*要做某事, 或某事的总体思路. 英语比代码更适合这些, 因为它是一种更具表现力的语言.

*UB:*

我对这种说法没有异议.

*JOHN:*

你是否担心注释会不正确或具有误导性, 并且这会减慢软件开发速度? 我经常听到人们抱怨过时的注释(通常作为不写注释的借口), 但我在我的职业生涯中并没有发现它们是一个重大问题. 不正确的注释确实会发生, 但我并不经常遇到它们, 当我遇到它们时, 它们很少花费我太多时间. 相比之下, 我浪费了*大量*时间, 因为文档不足; 对我来说, 花 50-80% 的开发时间阅读代码来弄清楚如果代码有适当的注释会很明显的事情并不罕见.

*UB:*

你和我有过一些非常不同的经历.

我当然得到了恰到好处的注释的帮助. 我也同样肯定(并且在本文档中)被不正确, 错位, 无端或只是糟糕的注释分散了注意力和困惑.

*JOHN:*

我邀请每个阅读本文的人问自己以下问题:

-   不正确的注释导致您的软件开发速度受到多大影响?
-   缺少注释导致您的软件开发速度受到多大影响?

对我来说, 缺少注释的成本很容易是不正确注释成本的 10-100 倍. 这就是为什么当我看到<Clean Code>中阻止人们写注释的东西时我会畏缩的原因.

让我们考虑 =PrimeGenerator= 类. 该代码中没有一个注释; 你觉得这合适吗?

*UB:*

我认为这对于我编写它的目的是合适的. 它是非常大的方法可以分解为包含较小方法的较小类的教训的附属品. 添加大量解释性注释会偏离这一点.

总的来说, 我在清单 4-8 中使用的注释风格更合适. 该清单位于*注释*章节的最后, 描述了另一个具有略有不同算法和更好注释集的 =PrimeGenertor=.

*JOHN:*

我不同意添加注释会分散你的观点, 我认为清单 4-8 也没有充分的注释. 但我们不要争论这两个问题. 相反, 让我们讨论一下 =PrimeGenerator= 代码在生产中使用时*应该*具有哪些注释. 我将提出一些建议, 你可以同意或不同意.

首先, 让我们讨论一下你对诸如 =isLeastRelevantMultipleOfLargerPrimeFactor= 之类的超长名称的使用. 我的理解是, 你主张使用这样的名称, 而不是使用较短的名称并辅以描述性注释: 你实际上是将注释移到代码中. 对我来说, 这种方法是有问题的:

-   长名称很尴尬. 开发人员每次调用方法时都必须重新输入方法的文档, 长名称会浪费水平空间并在代码中触发换行. 这些名字也很难读: 每次我读它时, 我的大脑都想解析每个音节, 这会让我慢下来. 请注意, 你和我都在本次讨论中使用了缩写名称: 这表明长名称很尴尬且无益.
-   这些名称难以解析, 并且不能像注释那样有效地传达信息. 当学生阅读 =PrimeGenerator= 时, 他们首先抱怨的事情之一是长名称(学生无法理解它们). 例如, 上面的名称含糊不清: " least relevant" 是什么意思, " larger prime factor" 是什么? 即使完全理解方法中的代码, 我也很难理解这个名称. 如果这个名称要消除对注释的需求, 它需要更长.

在我看来, 使用较短名称和描述性注释的传统方法更方便, 并且更有效地传达所需信息. 你提倡的方法有什么优点?

*UB:*

"_Megasyllabic_": 好词!

我喜欢我的方法名称是句子片段, 可以很好地与关键字和赋值语句配合使用. 它使代码阅读起来更自然.

        if (isTooHot)
          cooler.turnOn();

我还遵循一个关于名称长度的简单规则. 方法的范围越大, 其名称应该越短, 反之亦然--范围越短, 名称越长. 在这种情况下, 我提取的私有方法存在于非常小的范围内, 因此具有较长的名称. 像这样的方法通常只从一个地方调用, 因此程序员没有记住另一个调用的长名称的负担.

*JOHN:*

像 =isTooHot= 这样的名字对我来说完全没问题. 我关心的是像 =isLeastRelevantMultipleOfLargerPrimeFactor= 这样的名字.

有趣的是, 随着方法变得越来越小, 越来越窄, 你建议使用更长的名字. 这告诉我, 这些函数的接口更复杂, 所以需要更多的词来描述它们. 这为我之前的断言提供了支持证据, 即你越是拆分一个方法, 得到的方法就越浅.

/UB:/

不是函数变小了, 而是作用域变小了. 私有函数的作用域比调用它的公共函数小. 由该私有函数调用的函数的作用域更小. 当我们深入作用域时, 我们也会深入到情境细节中. 描述这些细节通常需要一个长名称或一个长注释. 我更喜欢使用名称.

至于长名称难以解析, 这是一个练习的问题. 代码中充满了需要练习才能习惯的东西.

/JOHN:/

我不接受这一点. 代码中可能充满了需要练习才能习惯的东西, 但这并不能成为它的借口. 需要更多练习的方法比需要更少练习的方法更糟糕. 如果需要大量工作才能适应长名称, 那么必须有一些补偿性的好处; 到目前为止, 我还没有看到任何好处. 而且我看不出有任何理由相信练习会使这些名字更容易理解.

此外, 你上面的评论违反了我的基本规则之一, 即" 复杂性在于读者的眼中" . 如果你写的代码别人认为很复杂, 那么你必须接受代码可能很复杂(除非你认为读者完全无能). 找借口或暗示这实际上是读者的问题(" 你只是没有足够的练习" )是不可以的. 稍后在我们的讨论中, 我将不得不遵循同样的规则.

/UB:/

够公平. 至于" leastRelevant" 的含义, 这是一个更大的问题, 你和我很快就会遇到. 它与作者对解决方案的熟悉程度以及读者缺乏这种熟悉程度有关.

/JOHN:/

你仍然没有回答我的问题: 为什么使用超长名称而不是使用较短名称并辅以描述性注释更好?

/UB:/

这对我来说是一个偏好问题. 我更喜欢长名称而不是注释. 我不相信注释会被维护, 我也不相信它们会被阅读. 你有没有注意到许多 IDE 将注释涂成浅灰色, 以便可以轻松忽略它们? 忽略名称比忽略注释更难.

(顺便说一句, 我让我的 IDE 将注释涂成鲜艳的消防车红色)

/JOHN:/

我不明白为什么一个怪物的名字比注释更有可能被" 维护" , 而且我不同意 IDE 鼓励人们忽略注释(这是你的偏见再次出现). 我目前的 IDE(VSCode)没有对注释使用较浅的颜色. 我以前的那个(NetBeans)使用了, 但配色方案并没有隐藏注释; 它以一种使代码和注释都更容易阅读的方式将它们与代码区分开来.

现在我们已经讨论了注释与长方法名称的具体问题, 让我们来谈谈一般的注释. 我认为需要注释有两个主要原因. 第一个原因是抽象. 简而言之, 没有注释, 就不可能有抽象或模块化.

抽象是良好软件设计中最重要的组成部分之一. 我将抽象定义为" 一种简化的思考方式, 它省略了不重要的细节. " 最明显的抽象例子是方法. 应该可以在不阅读方法代码的情况下使用方法. 我们通过编写一个描述方法*接口/(某人调用方法所需的所有信息)的头注释来实现这一点. 如果方法设计良好, 接口将比方法的代码简单得多(它省略了实现细节), 因此注释减少了人们必须牢记的信息量.

/UB:/

很久以前, 在 1995 年的一本书中, 我将抽象定义为:
>/放大事物的本质, 消除不相关的事物. /

我当然同意抽象对于良好的软件设计非常重要. 我也同意恰到好处的注释可以增强读者理解我们试图使用的抽象的能力. 我不同意注释是理解这些抽象的*唯一/, 甚至*最佳*方式. 但有时它们是唯一的选择.

但请考虑:

        addSongToLibrary(String title, String[] authors, int durationInSeconds);

在我看来, 这似乎是一个非常好的抽象, 我无法想象注释如何改进它.

/JOHN:/

我们对抽象的定义非常相似; 很高兴看到这一点.
然而, =addSongToLibrary= 声明还不是(还不是)一个好的抽象, 因为它省略了必不可少的信息. 为了使用 =addSongToLibrary=, 开发人员需要以下问题的答案:

-   作者字符串是否有任何预期的格式, 例如" LastName, FirstName" ?
-   作者是否应该按字母顺序排列? 如果不是, 顺序是否以其他方式重要?
-   如果库中已经有一首具有给定标题但作者不同的歌曲会怎样? 它会被新的替换吗, 还是库会保留多首同名歌曲?
-   库是如何存储的(例如, 它是否完全在内存中? 保存在磁盘上? )? 如果此信息已在其他地方记录, 例如整个类文档, 则无需在此处重复.

因此, =addSongToLibrary= 需要相当多的注释. 有时方法的签名(方法的名称和类型, 其参数和返回值)包含使用它所需的所有信息, 但这非常罕见. 只需浏览你最喜欢的库包的文档: 在多少情况下, 你只能通过其签名来理解如何使用方法?

/UB:/

是的, 有时方法的签名是一个不完整的抽象, 需要注释. 当接口是公共 API 的一部分, 或者是供单独开发团队使用的 API 的一部分时, 尤其如此. 然而, 在单个开发团队中, 接口上的长描述性注释通常更多的是一种障碍而不是帮助. 该团队对系统的内部结构非常了解, 并且通常能够仅从其签名中理解接口.

/JOHN:/

在我们的一次面对面讨论中, 你认为接口注释是不必要的, 因为当一组开发人员处理一段代码时, 他们可以集体将整个代码" 加载" 到他们的脑海中, 因此注释是不必要的: 如果你有问题, 只需询问熟悉该代码的人. 这会产生巨大的认知负荷来保持所有代码在精神上加载, 而且我很难想象它会真正起作用. 也许你的记忆力比我的好, 但我发现我很快就会忘记几周前写的代码. 在任何规模的项目中, 我认为你的方法会导致开发人员花费大量时间阅读代码以重新派生接口, 并且可能会在此过程中出错. 花几分钟记录接口将节省时间, 减少认知负荷, 并减少错误.

/UB:/

我认为某些接口需要注释, 即使它们对团队来说是私有的. 但我认为更常见的情况是, 团队对系统足够熟悉, 以至于名称良好的方法和参数就足够了.

/JOHN:/

让我们考虑一个来自 =PrimeGenerator= 的具体例子: =isMultipleOfNthPrimeFactor= 方法. 当阅读代码的人在 =isNot...= 中遇到对 =isMultiple...= 的调用时, 他们需要对 =isMultiple...= 的工作方式有足够的了解, 才能看到它如何融入 =isNot...= 的代码中. 方法名称没有完整地记录接口, 因此如果没有头注释, 读者将不得不阅读 =isMultiple= 的代码. 这将迫使读者将更多信息加载到他们的脑海中, 这使得在代码中工作更加困难.

这是我对 =isMultiple= 的头注释的第一次尝试:

#+begin_src
    /**
     * 如果 candidate 是 primes[n] 的倍数, 则返回 true, 否则返回 false.
     * 可能会修改 multiplesOfPrimeFactors[n].
     * @param candidate
     *      正在测试素数的数字; 必须至少与过去传递给此方法的任何值一样大.
     * @param n
     *      选择要测试的素数; 必须 <= multiplesOfPrimeFactors.size().
     */
#+end_src

你觉得这个怎么样?

/UB:/

我认为它是准确的. 如果我遇到它, 我不会删除它. 我不认为它应该是一个 javadoc.

第一句话与名称 =isMultipleOfNthPrimeFactor= 冗余, 因此可以删除. 警告副作用是有用的.

/JOHN:/

我同意第一句话在很大程度上与名称冗余, 并且我与自己争论过是否保留它. 我决定保留它, 因为我认为它比名称更精确; 它也更容易阅读. 你建议通过删除注释来消除注释和方法名称之间的冗余; 我将通过缩短方法名称来消除冗余.

顺便说一句, 你之前抱怨过注释不如代码精确, 但在这种情况下, 注释*更*精确(方法名称不能包含像 =primes[n]= 这样的文本).

/UB:/

够公平. 有时, 精度最好用注释表达.

继续我对你上面评论的批评: =candidate= 名称与" 正在测试素数的数字" 同义.

最后, 注释中的所有单词都必须坐在我的大脑中, 直到我理解它们为什么在那里. 我也要担心它们是否准确. 因此, 我将不得不阅读代码来理解和验证注释.

/JOHN:/

哇. 你刚才听到的那声巨响是我的下巴掉到地板上的声音. 帮我更好地理解一下: 你愿意在不阅读代码来验证的情况下信任你在实践中遇到的大约多少注释?

/UB:/

我将每个注释都视为潜在的错误信息. 充其量, 它们是一种将作者的意图与代码进行交叉检查的方法. 我对注释的信任程度在很大程度上取决于它们使交叉检查变得多么容易. 当我阅读一个不会导致我交叉检查的注释时, 我认为它没有任何价值. 当我看到一个导致我交叉检查的注释, 并且该交叉检查证明是有价值的时, 那是一个非常好的注释.

另一种说法是, 最好的注释告诉我一些关于代码的令人惊讶和可验证的东西. 最糟糕的是那些浪费我的时间告诉我一些明显或不正确的事情的注释.

/JOHN:/

听起来你的答案是 0%: 除非你阅读了代码来验证, 否则你不相信任何注释. 这对我来说毫无意义. 正如我上面所说, 绝大多数注释都是正确的. 写注释并不难; 我的软件设计课上的学生在几周内就做得很好. 随着代码的发展, 保持注释的最新状态也不难. 你拒绝信任注释是你对注释的非理性偏见的另一个迹象.

拒绝信任注释会产生很高的成本. 为了了解如何调用方法, 你将不得不阅读该方法的所有代码; 如果该方法调用其他方法, 你还必须阅读它们以及它们调用的方法, 递归地. 与阅读(并信任)像我上面写的简单接口注释相比, 这是一项巨大的工作量.

如果你选择不为方法编写接口注释, 那么你将不定义该方法的接口. 即使有人阅读了方法的代码, 他们也无法分辨实现的哪些部分预计会保持不变, 哪些部分可能会改变(没有办法在代码中指定这个" 契约" ). 这将导致误解和更多错误.

/UB:/

好吧, 我想我只是比你烧得更多. 我经历了太多由错误注释引起的兔子洞, 并且在毫无价值的文字沙拉上浪费了太多时间.

当然, 我对注释的信任不是二元的. 如果它们在那里, 我会阅读它们; 但我不隐式信任它们. 我觉得作者越是无端, 或者作者越不擅长英语, 我就越不信任这些注释.

正如我上面所说, 我们的 IDE 倾向于将注释涂成可忽略的颜色. 我让我的 IDE 将注释涂成鲜艳的消防车红色, 因为当我写注释时, 我希望它被阅读.

出于同样的原因, 我使用长名称作为注释的替代品, 因为我希望这些长名称被阅读; 而且程序员很难忽略名称.

/JOHN:/

我之前提到过需要注释的两个一般原因. 到目前为止, 我们一直在讨论第一个原因(抽象). 第二个一般原因是获取代码中不明显的重要信息. =PrimeGenerator= 中的算法非常不明显, 因此需要相当多的注释来帮助读者理解发生了什么以及为什么. 该算法的大部分复杂性源于它旨在有效地计算素数:

-   该算法竭尽全力避免除法, 这在 Knuth 编写他的原始版本时非常昂贵(现在它们并没有那么昂贵).

-   每个新素数的第一个倍数是通过将素数平方来计算的, 而不是将其乘以 3. 这很神秘: 为什么跳过中间的奇数倍数是安全的? 此外, 可能看起来这种优化对性能的影响很小, 但实际上它产生了*巨大*的差异(数量级). 使用平方有一个副作用, 即在测试候选数时, 只测试到候选数的平方根的素数. 如果使用 3x 作为初始倍数, 将测试候选数的 3 倍以内的素数; 这*多*了很多测试. 使用平方的这种含义非常不明显, 以至于我只在为这次讨论准备材料时才意识到它; 在我与学生多次讨论代码时, 我从未想到过这一点.

这两个问题在代码中都不明显; 没有注释, 读者只能自己弄清楚. 我的班上的学生通常无法在我给他们的 30 分钟内弄清楚其中任何一个, 但我认为注释可以让他们在几分钟内理解. 回到我的介绍性评论, 这是一个信息很重要的例子, 因此需要使其可用.

你是否同意应该有注释来解释这两个问题?

/UB:/

我同意这个算法很微妙. 将第一个素数倍数设置为素数的平方起初非常神秘. 我不得不骑自行车一个小时才能理解它.

注释会有帮助吗? 也许. 然而, 我猜我们对话的读者中没有人得到它的帮助, 因为你和我现在对解决方案太熟悉了. 你和我可以用适合这种亲密关系的词来谈论这个解决方案; 但我们的读者可能还没有享受到这种契合.

一种解决方案是画一幅画--值得一千个字. 这是我的尝试.

                                                                        X
                                                            1111111111111111111111111
               1111122222333334444455555666667777788888999990000011111222223333344444
           35791357913579135791357913579135791357913579135791357913579135791357913579
           !!! !! !! !  !!  ! !! !  !  !!  ! !!  ! !  !   ! !! !! !
         3 |||-||-||-||-||-||-||-||-||-||-||-||-||-||-||-||-||-||-||-||-||-
         5 |||||||||||-||||-||||-||||-||||-||||-||||-||||-||||-||||-||||-
         7 |||||||||||||||||||||||-||||||-||||||-||||||-||||||-||||||-||||||-
        11 |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||-||||||||||-
        13 ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
        ...
        113||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

我希望我们的读者将不得不盯着这个看一段时间, 并查看代码. 但随后他们的大脑中会有一个_咔嗒声_, 他们会说" 哦! 是的! 我现在看到了! "

/JOHN:/

我觉得这张图很难理解.
它需要补充的英文文本来解释所提出的想法. 甚至语法也不明显: =1111111111111111111111111= 是什么意思?

也许我们在这里有一个根本的哲学差异. 我的感觉是, 你很乐意给读者一些线索, 让他们自己把线索拼凑起来. 也许你不介意人们是否必须盯着某样东西看一段时间才能弄清楚它? 我不同意这种方法: 它会导致浪费时间, 误解和错误. 我认为软件应该是完全*明显*的, 读者不需要聪明或" 盯着这个看一段时间" 就能弄清楚事情. 痛苦之后是宣泄, 这对于希腊悲剧来说很棒, 但对于阅读代码来说却不行. 读者可能提出的每个问题都应该得到自然的回答, 无论是在代码中还是在注释中. 关键思想和重要结论应该明确说明, 而不是留给读者去推断. 理想情况下, 即使读者很匆忙并且没有非常仔细地阅读代码, 他们对事物如何工作(以及为什么)的第一个猜测也应该是正确的. 对我来说, 这就是干净的代码.

/UB:/

我不同意你的观点. 好的干净代码应该尽可能容易理解. 我想给我的读者尽可能多的线索, 以便代码直观易读.

这就是目标. 正如我们将要看到的, 这可能是一个难以实现的目标.

/JOHN:/

在这种情况下, 你还支持你上面画的" 图" 吗? 它似乎与你刚才所说的不一致. 如果你真的想给你的读者尽可能多的线索, 你会包含更多的注释.

/UB:/

就其准确性而言, 我支持这张图. 我认为这是一个很好的交叉检查. 我毫不怀疑它很容易理解.

这个算法具有挑战性, 需要工作才能理解. 当我骑自行车时在脑海中画出这张图时, 我终于明白了. 当我回到家时, 我把它画了出来, 并希望它可以帮助愿意做这项工作的人理解它.

** 注释总结

/JOHN:/

让我们总结一下讨论的这一部分. 这是我对我们同意和不同意的地方的总结.

-   我们对注释的总体看法根本不同. 我比你更重视注释的价值, 我认为它们在系统设计中发挥着根本性的, 不可替代的作用. 你同意在某些地方需要注释, 但注释并不总能使代码更容易理解, 因此你认为需要注释的地方要少得多.

-   对于给定的代码, 我可能会比你多写 5-10 倍的注释行.

-   我认为缺少注释比错误或无益的注释更容易导致生产力损失; 你认为注释总体上是负面的: 糟糕的注释比好的注释节省更多的时间.

-   你认为用英语而不是编程语言编写注释是有问题的. 我不认为这特别有问题, 并认为在许多情况下英语效果更好.

-   你建议开发人员应该获取我将表示为注释的信息, 并在可能的情况下将其重铸为代码. 一个例子是超长方法名称. 我认为超长名称很尴尬且难以理解, 最好使用较短的名称并辅以注释.

-   我认为没有大量的注释就不可能定义接口和创建抽象. 你同意公共 API, 但认为几乎不需要注释团队内部的接口.

-   在你阅读代码来验证它们之前, 你不愿意信任注释. 我通常信任注释; 通过这样做, 我不需要像你那样阅读那么多代码. 你认为这让我面临太多的风险.

-   我们都同意实现代码只有在代码不明显时才需要注释. 虽然我们都不主张大量的实现注释, 但我比你更有可能看到它们的价值.

总的来说, 我们很难在这个主题上找到共识.

/UB:/

这是对我们各自立场的公平评估; 我认为这是基于我们不同的个人经历. 多年来, 我发现绝大多数注释, 就像在行业中普遍使用的那样, 是无益的. 你似乎在你遇到的评论中找到了更多的帮助.

* John 对 PrimeGenerator 的重写

/JOHN:/

我提到过, 我让我的软件设计课上的学生重写 =PrimeGenerator= 来修复它所有的设计问题. 这是我的重写(注意: 这是在我们开始讨论之前写的; 鉴于我在讨论中学到的东西, 我现在会更改几个注释, 但我保留了它的原始形式):

        package literatePrimes;

        import java.util.ArrayList;

        public class PrimeGenerator2 {

            /*
             * 计算第一个素数; 返回值包含计算出的素数, 按大小递增的顺序.
             * @param n
             *      要计算多少个素数.
             */
            public static int[] generate(int n) {
                int[] primes = new int[n];

                // 用于有效地测试(无需除法)候选数是否是先前遇到的素数的倍数. 此处的每个条目都包含 primes 中相应条目的奇数倍数. 条目单调递增.
                int[] multiples = new int[n];

                // multiples 中最后一个值的索引, 我们需要在测试候选数时考虑它(此后的所有元素都大于我们当前的候选数, 因此不需要考虑它们).
                int lastMultiple = 0;

                // primes 中有效条目的数量.
                int primesFound = 1;

                primes[0] = 2;
                multiples[0] = 4;

                // 此循环的每次迭代都会考虑一个候选数; 跳过偶数, 因为它们不可能是素数.
                candidates: for (int candidate = 3; primesFound < n; candidate += 2) {
                    if (candidate >= multiples[lastMultiple]) {
                        lastMultiple++;
                    }

                    // 此循环的每次迭代都会根据一个潜在的素数因子测试候选数. 跳过第一个因子 (2), 因为我们只考虑奇数候选数.
                    for (int i = 1; i <= lastMultiple; i++) {
                        while (multiples[i] < candidate) {
                            multiples[i] += 2*primes[i];
                        }
                        if (multiples[i] == candidate) {
                            continue candidates;
                        }
                    }
                    primes[primesFound] = candidate;

                    // 从素数的平方开始, 而不是素数的 3 倍. 这节省了时间, 并且是安全的, 因为所有中间的倍数都将被较小的素数检测到. 例如, 考虑素数 7: 倍数中的值将从 49 开始; 21 将被排除为 3 的倍数, 35 将被排除为 5 的倍数, 因此 49 是第一个不会被较小素数排除的倍数.
                    multiples[primesFound] = candidate*candidate;
                    primesFound++;
                }
                return primes;
            }
        }

每个人都可以阅读这段代码并自己决定是否认为它比原始代码更容易理解. 我想提几点总体性的东西:

-   只有一个方法. 我没有细分它, 因为我觉得该方法已经自然地分成了不同的, 可理解的部分. 在我看来, 提取方法并不能显着提高可读性. 当学生重写代码时, 他们通常有 2 或 3 个方法, 这些方法通常也还可以.
-   有很多*很多*注释. 对我来说, 写出这种注释密度的代码非常罕见. 我写的大多数方法在正文中都没有注释, 只有一个描述接口的头注释. 但是这段代码很微妙和棘手, 所以它需要大量的注释来让读者清楚这些微妙之处. 一些注释的长度是一个危险信号, 表明我很难找到对代码的清晰简单的解释. 即使加上所有额外的解释性材料, 这个版本也比原始版本短一点(65 行对 70 行).

/UB:/

我假设这是一个完整的重写. 我猜你努力从<Clean Code>中理解了算法, 然后从头开始编写了这个. 如果是这样, 那就够公平了.

在<Clean Code>中, 我*重构*了 Knuth 的算法, 以便给它一些结构. 这与完全重写不同.

话虽如此, 你的版本比 Knuth 的或我的版本好得多.

我在 18 年前写了那一章, 所以距离我看到并理解这个算法已经很久了. 当我第一次看到你的挑战时, 我想: " 哦, 我可以弄清楚我自己的代码! " 但是, 不. 我可以看到所有活动部件, 但我无法弄清楚为什么这些活动部件会生成一个素数列表.

所以然后我看了你的代码. 我也有同样的问题. 我可以看到所有活动部件, 所有都带有注释, 但我仍然无法弄清楚为什么这些活动部件会生成一个素数列表.

弄清楚这一点需要盯着天花板, 闭上眼睛, 想象和骑自行车.

我遇到的问题包括你写的评论. 让我们一次处理它们.

            /*
             * 计算第一个素数; 返回值包含计算出的素数, 按大小递增的顺序.
             * @param n
             *      要计算多少个素数.
             */
            public static int[] generate(int n) {

在我看来, 这最好是:

        public static int[] generateNPrimeNumbers(int n) {

或者如果你必须:

        //返回前 n 个素数
        public static int[] generate(int n) {

我不反对 Javadocs 作为一项规则; 但我只在绝对必要时才写它们. 我也厌恶从方法签名中完全明显的描述和 =@param= 语句.

下一个评论花费了我整整 20 分钟的时间来弄清楚事情.

        // 用于有效地测试(无需除法)候选数是否是先前遇到的素数的倍数. 此处的每个条目都包含 primes 中相应条目的奇数倍数. 条目单调递增.

首先, 我不确定为什么需要" 除法" 语句. 我是老派的, 所以我希望每个人都知道如果可以避免的话, 要避免在内循环中进行除法. 但也许我对此是错的......

此外, /埃拉托色尼筛法*不进行除法, 并且比这个算法更容易理解*和解释/. 那么为什么选择这个特定的算法呢? 我认为 Knuth 试图节省_内存_--在 1982 年, 节省内存很重要. 这个算法比筛法使用更少的内存.

然后是这句话: =此处的每个条目都包含一个奇数倍数...=. 我看着它, 然后看着代码, 我看到: =multiples[0] = 4;=.

" 那不是奇数, " 我对自己说. " 所以也许他指的是偶数. "

然后我往下看, 看到: =multiples[i] += 2*primes[i];=

" 那是加上一个偶数! " 我对自己说. " 我很确定他想说' 偶数' 而不是' 奇数' . "

我还没有弄清楚 =multiples= 数组是什么. 所以我认为它里面有偶数是完全合理的, 而且你的评论只是一个可以理解的单词换位. 毕竟, 注释没有编译器, 所以它们会受到人类经常犯的单词错误的影响.

直到我看到 =multiples[primesFound] = candidate*candidate;= 我才开始质疑事情. 如果 =candidate= 是素数, 那么 =prime*prime= 在除了 2 之外的所有情况下都应该是奇数吗? 我不得不在脑海中做数学来证明这一点. (2n+1)(2n+1) = 4n^2+4n+1 ... 是的, 那是奇数.

好吧, 所以 =multiples= 数组充满了奇数倍数, 除了第一个元素, 因为它将是 2 的倍数.

所以也许那个评论应该是:

         // 相应素数的倍数.

或者也许我们应该将数组的名称更改为 =primeMultiples= 之类的名称, 并完全删除注释.

继续下一个注释:

        // 此循环的每次迭代都会根据一个潜在的素数因子测试候选数. 跳过第一个因子 (2), 因为我们只考虑奇数候选数.

这没有多大意义. 它谈论的代码是:

        for (int i = 1; i <= lastMultiple; i++) {
            while (multiples[i] < candidate) {

正如我们现在所了解的, =multiples= 数组是一个素数*倍数*的数组. 此循环不是根据素数*因子*测试候选数, 而是根据当前素数_倍数_测试它.

幸运的是, 当我第三次或第四次阅读此评论时, 我意识到你真的想使用" 倍数" 这个词. 但对我来说, 知道这一点的唯一方法是理解算法. 当我理解算法时, 为什么我需要注释?

这给我留下了一个最后的问题. 这背后的原因是什么:

        multiples[primesFound] = candidate*candidate;

为什么是平方? 这没有意义. 所以我把它改成:

        multiples[primesFound] = candidate;

而且它工作得很好. 所以这一定是一种优化.

你对此的评论是:

        // 从素数的平方开始, 而不是素数的 3 倍. 这节省了时间, 并且是安全的, 因为所有中间的倍数都将被较小的素数检测到. 例如, 考虑素数 7: 倍数中的值将从 49 开始; 21 将被排除为 3 的倍数, 35 将被排除为 5 的倍数, 因此 49 是第一个不会被较小素数排除的倍数.

前几次我读到它时, 它对我来说毫无意义. 这只是一堆数字.

我盯着天花板, 闭上眼睛想象. 我看不见它. 所以我去了一次漫长的沉思自行车之旅, 在此期间我意识到 2 的素数倍数在某个时候将包含 2\/3, 然后是 2\/5. 因此, =multiples= 数组在某个时刻将包含大于它们所代表的素数的素数倍数. _然后它就明白了! _

突然一切都变得有意义了. 我意识到 =multiples= 数组相当于我们在*埃拉托色尼筛法*中使用的布尔数组--但有一个非常有趣的转折. 如果你要在白板上做筛法, 你_可以_擦除每个小于候选数的数字, 并且只划掉那些是所有先前素数的下一个倍数的数字.

这个解释对我来说很有意义--现在, 但我愿意打赌那些正在阅读它的人正在为它烦恼. 这个想法很难解释.

最后, 我回到了你的评论, 可以看到你在说什么.

** 程序员的故事

最重要的是, 你和我都陷入了同样的陷阱. 18 年前, 我重构了那个旧算法, 我以为所有这些方法和变量名都会让我的意图清晰--/因为我理解那个算法/.

你前一段时间写了这段代码, 并用你认为可以解释你的意图的注释来装饰它--/因为你理解那个算法/.

但是我的名字 18 年后对我没有帮助. 它们对你或你的学生也没有帮助. 而且你的评论对我没有帮助.

我们在盒子里试图与那些站在外面的人交流, 他们看不到我们所看到的.

最重要的是, 很难向不熟悉你试图解释的细节的人解释某事. 通常, 只有在读者自己弄清楚细节之后, 我们的解释才有意义.

/JOHN:/

你的讨论中有很多内容, 但我认为这一切都归结为一件事: 你不喜欢我写的评论. 正如我之前提到的, 复杂性在于读者的眼中: 如果你说我的评论令人困惑或没有帮助你理解代码, 那么我必须认真对待.

与此同时, 你已经明确表示你认为一般的评论没有多大价值. 你的偏好是基本上没有关于这段代码(或任何代码)的注释. 你认为上面根本没有任何注释可以使代码更容易理解; 理解代码的唯一方法是阅读代码. 这是一个借口.

/UB:/

抱歉打断你; 但我认为你夸大了我的立场. 我当然从未说过评论永远没有帮助. 当然, 有时它们有帮助. 我说的是, 只有在代码验证它们时, 我才会信任它们. 有时注释会使验证更容易.

/JOHN:/

你一直说你有时候会发现注释有用, 但现实情况是, 在你的代码中" 有时" 几乎从未发生. 当我们查看你对我的代码的修订时, 我们会看到这一点.

现在回到我的观点. 为了编写我们各种版本的代码, 你和我必须积累大量关于算法的知识, 例如为什么素数的第一个倍数是它的平方是可以的. 不幸的是, 并非所有这些知识都可以用代码表示. 我们有专业责任尽最大努力在注释中传达这些知识, 以便读者不必一遍又一遍地重建它. 即使由此产生的注释不完美, 它们也会使代码更容易理解.

如果现实生活中发生这种情况, 我会与你和其他人合作来改进我的评论. 例如, 我会问你一些问题, 以便更好地了解为什么" 平方素数" 注释似乎对你没有帮助:

-   评论中是否有误导性或令人困惑的内容?
-   你在骑自行车时是否获得了一些重要的信息, 突然让事情变得清晰?

我还会将评论展示给其他几个人, 以了解他们的看法. 然后我会重新编写评论以改进它.

鉴于你对评论的根本不信任, 我认为即使在我重新编写之后, 你仍然会认为评论没有价值. 在这种情况下, 我会将评论展示给其他人, 特别是那些对注释总体上有更积极看法的人, 并获得他们的意见. 只要评论没有误导性, 并且至少有一些人觉得它有帮助, 我就会保留它.

现在让我讨论一下你反对的两个具体评论. 第一个评论是关于 =multiples= 变量的:

        // 用于有效地测试(无需除法)候选数是否是先前遇到的素数的倍数. 此处的每个条目都包含 primes 中相应条目的奇数倍数. 条目单调递增.

你发现这个评论中有一个错误(第一个条目不是奇数); 好眼力! 然后你认为注释中的大部分信息是不必要的, 并提出了一个替代方案:

         // 相应素数的倍数.

你在这里遗漏了太多有用的信息. 例如, 我不认为假设读者会发现动机是避免除法是安全的. 总是最好清楚地说明这些假设和动机, 这样就不会有任何混淆. 而且我认为让读者知道这些条目永远不会减少是有帮助的. 我只需修复错误, 保留所有信息完整:

        // 用于有效地测试(无需除法)候选数是否是先前遇到的素数的倍数. 每个条目(除了第一个, 它从未使用)都包含 primes 中相应条目的奇数倍数. 条目单调递增.

第二个注释是这个, 用于 =for= 循环:

        // 此循环的每次迭代都会根据一个潜在的素数因子测试候选数. 跳过第一个因子 (2), 因为我们只考虑奇数候选数.

你反对这个评论, 因为循环的代码实际上并没有根据素数因子测试候选数; 它根据倍数测试它. 当我写这样的实现注释时, 我的目标不是重述代码; 像这样的评论通常不会提供太多价值. 这里的目标是从逻辑上说明代码正在做*什么/, 而不是它*如何*做. 从这个意义上说, 评论是正确的.

但是, 如果注释导致读者困惑, 那么它就不是一个好的注释. 因此, 我会重写此注释以明确表示它描述了代码的抽象功能, 而不是其精确行为:

        // 此循环的每次迭代都会考虑一个现有的素数, 如果候选数是该素数的倍数, 则排除该候选数. 跳过第一个素数 (2), 因为我们只考虑奇数候选数.

总之, 我同意你的断言" 很难向不熟悉你试图解释的细节的人解释某事. " 然而, 这是我们作为程序员的责任去做的事情.

/UB:/

我很高兴我们同意. 我们也同意让其他人审查代码并对代码_和_注释提出建议.

* Bob 对 PrimeGenerator2 的重写

/UB:/

当我看到你的解决方案时, 在我对它有了很好的理解之后. 我稍微重构了一下. 我将它加载到我的 IDE 中, 编写了一些简单的测试, 并提取了一些简单的方法.

我也摆脱了那个*可怕*的带标签的 =continue= 语句. 我将 3 添加到素数列表中, 以便我可以将第一个元素标记为*不相关*并给它一个值 -1. (我想我仍然对偶数/奇数混乱感到震惊. )

我喜欢这个, 因为 =generateFirstNPrimes= 方法的实现以一种暗示正在发生的事情的方式描述了活动部件. 阅读该实现并了解该机制很容易. 我完全不确定注释是否有帮助.

我认为这只是这个算法的现实, 即正确解释它所需的努力, 以及其他人阅读和理解该解释所需的努力, 大致相当于阅读代码和骑自行车所需的努力.

#+begin_src java
        package literatePrimes;

        public class PrimeGenerator3 {
            private static int[] primes;
            private static int[] primeMultiples;
            private static int lastRelevantMultiple;
            private static int primesFound;
            private static int candidate;

            // 可爱的小算法, 通过预测下一个合数并跳过它来找到素数. 该预测由一组不断增加以跟上候选数的素数倍数组成.

            public static int[] generateFirstNPrimes(int n) {
                initializeTheGenerator(n);

                for (candidate = 5; primesFound < n; candidate += 2) {
                    increaseEachPrimeMultipleToOrBeyondCandidate();
                    if (candidateIsNotOneOfThePrimeMultiples()) {
                        registerTheCandidateAsPrime();
                    }
                }
                return primes;
            }



        private static void initializeTheGenerator(int n) {
            primes = new int[n];
            primeMultiples = new int[n];
            lastRelevantMultiple = 1;

            // prime the pump. (Sorry, couldn't resist.)
            primesFound = 2;
            primes[0] = 2;
            primes[1] = 3;

            primeMultiples[0] = -1;// irrelevant
            primeMultiples[1] = 9;
        }

        private static void increaseEachPrimeMultipleToOrBeyondCandidate() {
            if (candidate >= primeMultiples[lastRelevantMultiple])
                lastRelevantMultiple++;

            for (int i = 1; i <= lastRelevantMultiple; i++)
                while (primeMultiples[i] < candidate)
                    primeMultiples[i] += 2 * primes[i];
        }

        private static boolean candidateIsNotOneOfThePrimeMultiples() {
            for (int i = 1; i <= lastRelevantMultiple; i++)
                if (primeMultiples[i] == candidate)
                    return false;
            return true;
        }

        private static void registerTheCandidateAsPrime() {
            primes[primesFound] = candidate;
            primeMultiples[primesFound] = candidate * candidate;
            primesFound++;
        }
}
#+end_src

*JOHN:*

这个版本比 /Clean Code/ 中的版本有了很大的改进. 减少方法的数量使代码更容易阅读, 并产生了更清晰的接口. 如果它有适当的注释, 我认为这个版本将和我的一样容易阅读(你创建的额外方法并没有特别的帮助, 但它们也没有坏处). 我怀疑, 如果我们对读者进行调查, 有些人会更喜欢你的版本, 有些人会更喜欢我的.

不幸的是, 这个修订版的代码造成了严重的性能倒退: 我测量到与之前的任一修订版相比, 速度下降了 3-4 倍. 问题在于, 你将处理特定候选数的过程从单个循环更改为两个循环(=increaseEach...= 和 =candidateIsNot...= 方法). 在之前修订版的循环中, 以及在 =candidateIsNot= 方法中, 一旦候选数被取消资格, 循环就会中止(并且大多数候选数很快就会被淘汰). 但是, =increaseEach...= 必须检查 =primeMultiples= 中的每个条目. 这导致循环迭代次数增加了 5-10 倍, 总体速度下降了 3-4 倍.

鉴于当前算法(及其复杂性)的全部原因是为了最大限度地提高性能, 这种减速是不可接受的. 这两个方法必须合并.

我认为这里发生的事情是, 你过于专注于一些实际上并不那么重要的事情(创建尽可能小的方法), 以至于你在其他真正重要的问题上掉了链子. 我们现在已经看到了两次. 在 =PrimeGenerator= 的原始版本中, 你如此执着于创建微小的方法, 以至于你没有注意到代码变得难以理解. 在这个版本中, 你如此渴望分解我的单个方法, 以至于你没有注意到你正在炸毁性能.

我不认为这仅仅是疏忽的不幸组合. 软件设计中最重要的事情之一是确定什么是重要的并专注于此; 如果你专注于不重要的事情, 你很可能会搞砸真正重要的事情.

你修订版中的代码仍然注释不足. 你认为注释没有任何有意义的方式来帮助读者理解代码. 我认为这源于你对注释价值的普遍不信任; 你很快就认输了. 这个算法非常难以解释, 但我仍然相信注释可以提供帮助. 例如, 我认为你必须尝试帮助读者理解为什么素数的第一个倍数是素数的平方. 你花了很多时间来发展你对这一点的理解; 肯定有某种方法可以将这种理解传达给其他人? 如果你在你的原始版本代码中包含了这些信息, 你就可以省去那次漫长的自行车骑行. 放弃这是对专业责任的放弃.

你在修订版中包含的少数注释几乎没有价值. 第一个注释太隐晦, 无法提供太多帮助: 即使我完全理解它声称要解释的代码, 我也无法理解" 预测下一个合数并跳过它" 这个短语. 其中一个注释只是一个笑话; 鉴于你反对无关的注释, 看到这一点我很惊讶.

显然, 当涉及到注释时, 你和我生活在不同的世界.

最后, 我不明白你为什么对我的代码中带标签的 =continue= 语句感到不满. 这是一个干净而优雅的解决方案, 可以解决从嵌套循环中转义的问题. 我希望更多的语言具有此功能; 另一种方法是笨拙的代码, 你设置一个变量, 然后退出一级循环, 然后检查变量并退出下一级.

*UB:*

好眼力! 如果我想到了对解决方案进行分析, 我也会发现这一点. 你是对的, 分离两个循环增加了一些不必要的迭代. 我找到了一个很好的方法来解决这个问题, 而无需使用可怕的 =continue=. 我的更新版本现在比你的快! 一百万个素数在 440 毫秒内, 而你的需要 561 毫秒. ;-) 下面只是更改.

#+begin_src java
          public static int[] generateFirstNPrimes(int n) {
            initializeTheGenerator(n);

            for (candidate = 5; primesFound < n; candidate += 2)
              if (candidateIsPrime())
                registerTheCandidateAsPrime();

            return primes;
          }

          private static boolean candidateIsPrime() {
            if (candidate >= primeMultiples[lastRelevantMultiple])
              lastRelevantMultiple++;

            for (int i = 1; i <= lastRelevantMultiple; i++) {
              while (primeMultiples[i] < candidate)
                primeMultiples[i] += 2 * primes[i];
              if (primeMultiples[i] == candidate)
                return false;
            }
            return true;
          }
#+end_src

*JOHN:*

是的, 这解决了问题. 我注意到你现在减少到 4 个方法, 而 /Clean Code/ 版本中有 8 个.

** 测试驱动开发

*JOHN:*

让我们继续讨论我们的第三个分歧领域, 即测试驱动开发. 我是单元测试的忠实粉丝. 我相信单元测试是软件开发过程中不可或缺的一部分, 并且一次又一次地得到回报. 我认为我们在这方面意见一致.

但是, 我不是测试驱动开发 (TDD) 的粉丝, 它规定必须在代码之前编写测试, 并且必须以微小的增量编写和测试代码. 这种方法存在严重的问题, 而我无法确定任何补偿优势.

*UB:*

正如我一开始所说, 我仔细阅读了 _A Philosophy of Software Design_. 我发现它充满了有价值的见解, 我非常同意你的大部分观点.

所以当我在第 157 页发现你写了一个非常简短的, 轻蔑的, 贬损的, 不准确的关于_测试驱动开发_的部分时, 我很惊讶. 抱歉使用了这么多形容词, 但我认为这是一个公平的描述. 所以我的目标是纠正导致你写下以下内容的误解:

>" 测试驱动开发是一种软件开发方法, 程序员在编写代码之前先编写单元测试. 在创建一个新类时, 开发人员首先根据其预期行为为该类编写单元测试. 这些测试都不会通过, 因为没有该类的代码. 然后, 开发人员一次处理一个测试, 编写足够的代码以使该测试通过. 当所有测试都通过时, 该类就完成了. "

这完全是错误的. TDD 与你描述的完全不同. 我用三个定律来描述它.

 1. 在编写一个因为该代码不存在而失败的单元测试之前, 你不允许编写任何生产代码.

 2. 你不允许编写超出足以失败的单元测试, 并且编译失败就是失败.

 3. 你不允许编写超出足以使当前失败的测试通过的生产代码.

稍微思考一下, 你就会相信, 这三个定律会把你锁定在一个只有几秒钟长的循环中. 你将编写一两行将失败的测试, 你将编写一两行将通过的生产代码, 每隔几秒钟循环一次.

TDD 的第二层是红-绿-重构循环. 这个循环有几分钟长. 它由几个三定律循环组成, 然后是一段反思和重构的时期. 在那次反思中, 我们从快速循环的亲密关系中抽身出来, 看看我们刚刚编写的代码的设计. 它干净吗? 结构良好吗? 有没有更好的方法? 它是否符合我们正在追求的设计? 如果没有, 应该吗?

*JOHN:*

哎呀! 我承认对 TDD 的描述不准确" 有罪" . 我将在 APOSD 的下一个版本中修复此问题. 也就是说, 你对 TDD 的定义并没有改变我的担忧.

让我们讨论一下 TDD 的潜在优点和缺点; 然后读者可以自己决定他们是否认为 TDD 总体上是一个好主意.

在我们开始讨论之前, 让我澄清一下我更喜欢的方法, 作为 TDD 的替代方案. 在你的在线视频中, 你将 TDD 的替代方案描述为开发人员编写代码, 使其完全正常工作(大概是手动测试), 然后返回并编写单元测试. 你认为这种方法会很糟糕: 开发人员一旦认为代码正常工作就会失去兴趣, 因此他们实际上不会编写测试. 我完全同意你的看法. 但是, 这不是 TDD 的唯一替代方案.

我更喜欢的方法是开发人员以比 TDD 中更大的单位工作, 也许是几个方法或一个类. 开发人员首先编写一些代码(从几十行到几百行), 然后为该代码编写单元测试. 与 TDD 一样, 在拥有全面的单元测试之前, 代码不被认为是" 正常工作" 的.

*UB:*

为了本文档的目的, 我们是否可以将此技术称为" 捆绑" ? 这是我在 _Clean Code 第二版_ 中使用的术语.

*JOHN:*

我同意.

以更大的单位工作的原因是为了鼓励设计思维, 以便开发人员可以考虑一组相关的任务并进行一些计划, 以提出一个良好的整体设计, 其中各个部分很好地结合在一起. 当然, 最初的设计思想会有缺陷, 仍然需要重构, 但目标是围绕设计而不是测试来集中开发过程.

为了开始我们的讨论, 你能列出你认为 TDD 比我刚才描述的方法提供的优势吗?

*UB:*
我通常认为 TDD 的优势是:

-   几乎不需要调试. 毕竟, 如果你几分钟前才看到一切正常工作, 那么就没有什么可调试的了.

-   以非常小且隔离的单元测试形式出现的可靠的低级文档流. 这些测试描述了系统每个方面的低级结构和操作. 如果你想知道如何在系统中做某事, 有一些测试会告诉你如何做.

-   一种不那么耦合的设计, 这是由于系统的每个小部分都必须设计为可测试的, 而可测试性需要解耦.

-   一套你用生命信任的测试, 因此支持无所畏惧的重构.

但是, 你问我 TDD 可能比_你_首选的方法有哪些优势. 这取决于你将我刚才描述的那些较大的单元放多大. 对我来说, 重要的是保持循环时间短, 并防止阻碍可测试性的纠缠.

在我看来, 以小单位工作, 然后在事后立即编写测试, 可以为你提供所有上述优势, 只要你非常小心地测试你刚刚编写的代码的各个方面. 我认为一个有纪律的程序员可以有效地以这种方式工作. 事实上, 我认为这样的程序员会产生我无法区分的代码, 这些代码是由另一个遵循 TDD 的程序员编写的.

上面你建议捆绑是为了鼓励设计. 我认为鼓励设计是一件非常好的事情. 我的问题是: 你为什么认为 TDD 不鼓励设计? 我自己的经验是, 设计来自战略思维, 这与 TDD 或捆绑的战术行为无关. 设计是从代码中退后一步, 并设想解决更大一组约束和需求的结构.

一旦你有了这个愿景, 在我看来, 捆绑和 TDD 将产生类似的结果.

*JOHN:*

首先, 让我来解决你列出的 TDD 的四个优点:

-   几乎不需要调试?  我认为任何形式的单元测试都可以减少调试工作, 但不是因为你建议的原因. 好处在于单元测试更早地暴露了错误, 并且在更容易追踪的环境中. 在开发中修复一个相对简单的错误, 在生产中追踪它可能会非常痛苦. 我不相信你的论点, 即调试更少是因为" 你几分钟前才看到一切正常工作" : 很容易做出一个微小的更改, 暴露一个已经存在很长时间但尚未触发的非常棘手的错误. 难以调试的问题源于系统累积的复杂性, 而不是代码增量的大小.

        >*UB:* 正确. 然而, 当周期非常短时, 即使是最棘手的错误的根本原因也有最好的机会被追踪到. 周期越短, 机会就越大.

        >*JOHN:* 这只是在某种程度上是正确的. 我认为你相信使单位越来越小会继续提供好处, 几乎没有限制它们可以变得多小. 我认为有一个收益递减点, 在这个点上, 使事物更小不再有帮助, 实际上开始造成伤害. 我们在方法长度上看到了这种分歧, 我认为我们在这里再次看到了它.

-   低级文档? 我不同意: 单元测试是一种糟糕的文档形式. 注释是一种更有效的文档形式, 你可以将它们放在相关代码旁边. 试图通过阅读一堆单元测试来学习方法的接口似乎比只阅读几句英文文本要困难得多.

        >*UB:* 现在, 使用 IDE 的" where-used" 功能很容易找到函数的测试. 至于注释更好, 如果这是真的, 那么没有人会发布示例代码.

-   一种不那么耦合的设计? 可能吧, 但我自己没有经历过. 目前尚不清楚为可测试性进行设计是否会产生最佳设计.

        >*UB:* 通常, 解耦的产生是因为测试需要某种模拟. 模拟往往会强制产生原本不存在的抽象.

        >*JOHN:* 根据我的经验, 模拟几乎从不更改接口; 它只是为现有(通常不可移动)接口提供替换.

        >*UB:* 我们的经历不同.

-   启用无所畏惧的重构? 答对了! 这几乎是单元测试的所有好处的来源, 这是一件非常非常重要的事情.

        >*UB:* 同意.

我同意你的结论, 即 TDD 和捆绑在提供这些好处方面是相同的.

现在让我解释一下为什么我认为 TDD 可能导致糟糕的设计. TDD 的根本问题在于它迫使开发人员过于战术性地工作, 以至于开发单位太小; 它阻碍了设计思维. 使用 TDD, 开发的基本单位是一个测试: 首先编写测试, 然后编写代码以使该测试通过. 然而, 设计的自然单位比这更大: 例如, 一个类或方法. 这些单元对应于多个测试用例. 如果开发人员只考虑下一个测试, 他们只考虑给定时间的某个设计问题的一部分. 如果你不同时考虑整个设计问题, 就很难很好地设计某些东西. TDD 明确禁止开发人员编写超出通过当前测试所需的代码; 这阻碍了良好设计所需的战略思维.

TDD 没有提供足够的指导来鼓励设计. 你提到了红-绿-重构循环, 它建议在每个步骤之后进行重构, 但几乎没有关于重构的指导. 开发人员应该如何决定何时以及重构什么? 这似乎完全取决于他们自己的判断. 例如, 如果我正在编写一个需要多次 TDD 循环迭代的方法, 我应该在每次迭代后进行重构(这听起来很乏味)还是等待几次迭代, 以便我可以在重构时查看更大的代码块, 从而更具战略性? 如果没有指导, 开发人员很可能会不断推迟重构.

TDD 与我们之前讨论的" 一件事" 规则类似, 因为它存在偏见: 它提供了非常强烈而明确的指示, 将开发人员推向一个方向(在这种情况下, 是战术行动), 而在另一个方向(更具战略性的设计)上只有模糊的指导. 因此, 开发人员可能会犯过于战术性的错误.

TDD 保证开发人员最初会编写糟糕的代码. 如果你在没有考虑整个设计问题的情况下开始编写代码, 你编写的第一个代码几乎肯定是错误的. 只有在积累了一堆糟糕的代码之后才会发生设计. 我观看了你的 TDD 视频, 你反复编写错误的代码, 然后修复它. 如果开发人员认真地进行重构(就像你所做的那样), 他们仍然可以得到好的代码, 但这违背了人性. 使用 TDD, 那些糟糕的代码实际上会起作用(有测试证明它! ), 而不想更改有效的东西是人之常情. 如果我正在开发的代码不重要, 我可能必须使用 TDD 积累大量糟糕的代码, 然后我才有足够的代码摆在我面前, 以了解设计应该是什么样子. 我很难强迫自己扔掉所有的工作.

开发人员很容易相信他们在正确地进行 TDD, 同时完全战术性地工作, 一个接一个地进行黑客攻击, 偶尔进行一些小的重构, 而从不考虑整体设计.

我认为捆绑方法优于 TDD, 因为它将开发过程集中在设计上: 首先设计, 然后编写代码, 然后编写单元测试. 当然, 仍然需要重构: 几乎不可能在第一时间就获得正确的设计. 但是从设计开始将减少你编写的糟糕代码的数量, 并让你更快地获得良好的设计. 使用 TDD 可以产生同样好的设计; 这只是更难, 需要更多的纪律.

*UB:*

我将逐一解决你的观点.

-   我没有发现 TDD 的规模如此战术性, 以至于它阻碍了思考. 每个程序员, 无论他们的测试纪律如何, 都会一次写一行代码. 这是非常战术性的, 但并没有阻碍设计. 那么为什么一次一个测试会阻碍它呢?

-   关于 TDD 的文献强烈反对延迟重构. 虽然强烈鼓励思考设计. 两者都是该学科不可或缺的一部分.

-   我们一开始都写了糟糕的代码. TDD 的纪律给了我们机会和安全, 可以不断地清理它. 设计见解来自这些类型的清理活动. 重构的纪律允许将糟糕的设计一步一步地转化为更好的设计.

-   我不清楚为什么迟写测试是更好的设计选择. TDD 中没有任何东西可以阻止我在编写第一个测试代码之前很久就考虑设计.

*JOHN:*

你说 TDD 中没有任何东西可以阻止开发人员提前思考设计. 这只是部分正确. 在 TDD 下, 我可以提前思考, 但我不能真正以代码的形式写下我的想法, 因为这会违反 TDD 规则 1. 这是一个重大的阻碍.

你声称 TDD 中" 强烈鼓励思考设计" , 但我在你关于 TDD 的讨论中没有看到这一点. 我观看了你关于使用 TDD 计算保龄球分数的视频示例, 在最初的一两分钟之后, 设计甚至从未被提及(具有讽刺意味的是, 这个示例的结论之一是, 简短的初始设计结果证明毫无用处). 视频中没有提前思考的建议; 这都是关于事后清理烂摊子. 在你向我展示的所有 TDD 材料中, 我没有看到任何关于变得如此战术性以至于设计永远不会发生的危险的警告(也许你甚至不认为这是一个严重的风险? ).

*UB:*

我通常使用 UML 的缩写形式来捕捉我早期的设计决策. 我不反对用伪代码, 甚至真实代码来捕捉它们. 但是, 我不会提交任何此类预先编写的代码. 我可能会把它保存在一个文本文件中, 并在遵循 TDD 循环时查阅它. 我可能会感到足够安全, 可以将文本文件中的内容复制并粘贴到我的 IDE 中, 以便使失败的测试通过.

保龄球游戏是一个例子, 说明我们最初的设计决策与我们最终的解决方案可能有多么大的偏差. 确实, 介绍性视频通常不会揭示学科的深度.

*JOHN:*

当我在第二次观看你的 TDD 视频时, 你说了一些让我眼前一亮的东西:
 >人类认为首先出现的事情很重要, 而最后出现的事情则不那么重要, 并且在某种程度上是可选的; 这就是为什么它们在最后, 所以如果需要, 我们可以把它们排除在外.

这完美地捕捉了我对 TDD 的担忧. TDD 坚持认为测试必须放在首位, 而设计, 如果它发生的话, 则是在代码工作之后才出现的. 我认为良好的设计是最重要的事情, 因此它必须是重中之重. 我不认为测试是可选的, 但延迟它们比延迟设计更安全. 编写测试并不特别困难; 最重要的是要有纪律去做. 获得良好的设计非常困难, 即使你非常有纪律; 这就是为什么它需要成为关注的中心.

*UB:*

TDD 是一种编码规范. 当然, 设计先于编码--我不知道有谁会不这么认为. 即使是保龄球游戏视频也说明了这一点. 但是, 正如我们在保龄球游戏视频中看到的那样, 有时代码会将你带到一个非常不同的方向.

这种差异并不意味着不应该进行设计. 这只是意味着设计是推测性的, 可能并不总是能够经受住现实的考验.

正如艾森豪威尔曾经说过的:
>" 在准备战斗时, 我一直发现计划毫无用处, 但计划是必不可少的. "

*JOHN:*

你问为什么稍后编写测试是更好的设计选择. 事实并非如此. 捆绑方法的好处并非来自稍后编写测试; 它来自更早地进行设计. 编写测试(稍后一点)是这个选择的结果. 测试仍然在捆绑方法中很早就编写好了, 所以我不认为延迟会导致重大问题.

*UB:*

我认为我们只是不同意 TDD 是否阻碍了设计. TDD 的实践并没有阻止我进行设计; 因为我重视设计. 我建议那些不重视设计的人不会进行设计, 无论他们实践什么规范.

*JOHN:*

你声称我担心的 TDD 问题在实践中根本不会发生. 不幸的是, 我从我信任的高级开发人员那里听到了相反的说法. 他们抱怨基于 TDD 的团队产生了可怕的代码, 他们认为这些问题是由 TDD 引起的. 当然, 任何设计方法都可能产生可怕的代码. 也许那些团队没有正确地实施 TDD, 或者也许那些案例是异常值. 但向我报告的问题与我预期的完全一致, 因为 TDD 的战术性质.

*UB:*

我的经验不同. 我参与过许多有效且有利地使用 TDD 的项目. 我确信你信任的高级开发人员正在告诉你他们的经验. 我自己从未见过 TDD 导致如此糟糕的结果, 我真诚地怀疑责任可以追溯到 TDD.

*JOHN:*

你让我相信你在 TDD 方面的丰富经验, 我承认我个人没有 TDD 方面的经验. 另一方面, 我在战术编程方面有很多经验, 我知道它很少有好结果. TDD 是我遇到的最极端的战术编程形式之一. 总的来说, 如果" 让它工作" 是第一要务, 而不是" 开发一个干净的设计" , 代码就会变成意大利面条. 我在你的 TDD 方法中看不到足够的保障措施来防止灾难场景; 我甚至没有看到对风险的明确认识.

总的来说, TDD 在风险-回报谱上处于一个糟糕的位置. 与捆绑方法相比, TDD 中糟糕代码质量的下行风险是巨大的, 我没有看到足够的上行回报(如果有的话)来补偿.

*UB:*

对于这一点, 我只能说你的意见是基于一些错误的印象和猜测, 而不是基于直接的经验.

*JOHN:*

现在让我问你几个问题.

首先, 在微观层面上, 为什么 TDD 禁止开发人员编写超出通过当前测试所需的代码? 强制短视如何使系统更好?

>*UB:*
该学科的目标是确保一切都经过测试. 做到这一点的一个好方法是拒绝编写任何代码, 除非它是为了使失败的测试通过. 此外, 在如此短的周期内工作可以深入了解代码的工作方式. 这些见解通常会导致更好的设计决策.

>*JOHN:*
我同意看到代码(部分)工作可以提供见解. 但肯定可以在对开发人员思考方式没有如此严格限制的情况下获得这种好处吗?

其次, 在更广泛的层面上, 你是否认为 TDD 比更以设计为中心的方法(例如我上面描述的捆绑方法)更有可能产生更好的设计? 如果是, 你能解释一下为什么吗?

>*UB:*
我猜想, 擅长捆绑的人和擅长 TDD 的人会产生非常相似的设计, 并且具有非常相似的测试覆盖率. 我还想大胆猜测, TDDer 的生产力会比 bundler 高一些, 如果不是因为 TDDer 比 bundler 更早地发现和修复问题.

>*JOHN:*
我认为捆绑方法会产生更好的设计, 因为它实际上专注于设计, 而不是专注于测试并希望良好的设计会神奇地出现. 我认为很难争辩说, 实现一件事的最佳方法是将注意力集中在其他事情上. 捆绑方法将更快地取得进展, 因为早期对设计的思考将减少你在 TDD 下最终不得不丢弃的糟糕代码的数量. 总的来说, 我认为这两种方法的最佳情况结果将大致相同, 但平均情况和(尤其是)最坏情况的结果对于 TDD 来说会糟糕得多.

*JOHN:*

我不认为我们会解决我们在 TDD 上的分歧. 要做到这一点, 我们需要关于 TDD 产生好结果和坏结果的频率的经验数据. 不幸的是, 我不知道有任何此类数据. 因此, 读者将不得不自己决定 TDD 的潜在好处是否大于风险.

对于任何选择使用 TDD 的人, 我敦促你极其谨慎地这样做. 你的主要目标不能仅仅是工作代码, 而是一个干净的设计, 这将允许你在未来快速开发. TDD 不会自然地引导你获得最佳设计, 因此你需要进行大量且持续的重构以避免意大利面条代码. 反复问自己" 假设我在最初开始这个项目时就知道我现在知道的一切; 我会选择当前的代码结构吗? " 当答案是否定时(这会经常发生), 停止并重构. 认识到 TDD 会导致你编写比你可能习惯的更多的糟糕代码, 因此你必须准备好比你习惯的更多地丢弃和重写. 花时间提前计划并思考整体设计, 而不是仅仅让下一个测试起作用. 如果你认真地做所有这些事情, 我认为有可能减轻 TDD 的风险并产生设计良好的代码.

*UB:*

让我们这样说, 我同意所有这些建议, 但不同意你的断言, 即 TDD 可能是糟糕代码的原因.

* TDD 总结

*JOHN:*

这是我尝试总结我们对测试驱动开发的看法:

-   我们都同意单元测试是软件开发中必不可少的元素. 它们允许开发人员在不担心破坏某些东西的情况下对系统进行重大更改.

-   我们都同意可以使用 TDD 来产生具有良好设计的系统.

-   我认为 TDD 阻碍了良好的设计, 并且很容易导致非常糟糕的代码. 你不相信 TDD 阻碍了良好的设计, 并且没有看到糟糕代码的风险.

-   我认为有比 TDD 更好的方法来产生良好的单元测试套件, 例如上面讨论的" 捆绑" 方法. 你同意捆绑可以产生与 TDD 一样好的结果, 但认为它可能导致测试覆盖率略低.

-   我认为 TDD 和捆绑具有相似的最佳情况结果, 但 TDD 的平均情况和最坏情况的结果会糟糕得多. 你不同意, 并认为, 如果有什么不同的话, TDD 可能会产生比捆绑略好的结果. 你还认为偏好和个性是做出选择的更大因素.

*UB:*

这是我们讨论的公平总结. 我们似乎不同意纪律的最佳应用. 我更喜欢一种有纪律的方法, 让代码被非常短的周期内首先编写的测试覆盖. 你更喜欢一种有纪律的方法, 即编写相对较长的代码包, 然后为这些包编写测试. 我们不同意这两种规范的风险和回报.

* 结束语

*JOHN:*

首先, 我要感谢你容忍(并回应)我对 /Clean Code/ 中一些关键思想提出的论点. 我希望这次讨论能为读者提供思考的素材.

我们在这次讨论中涵盖了很多主题和子主题, 但我认为我的大多数担忧都是由 /Clean Code/ 犯下的两个一般性错误造成的: 未能关注什么是重要的, 以及未能平衡设计权衡.

在软件设计中(可能在任何设计环境中), 识别真正重要的事情并专注于这些事情至关重要. 如果你将注意力集中在不重要的事情上, 你就不太可能实现真正重要的事情. 不幸的是, /Clean Code/ 反复关注那些并不重要的事情, 例如:

-   将十行方法划分为五行方法, 并将五行方法划分为两行或三行方法.
-   消除使用英语编写的注释.
-   在代码之前编写测试, 并使开发的基本单位成为测试而不是抽象.

这些都没有提供重要的价值, 我们已经看到了它们如何分散人们对产生最佳设计的注意力.

相反, /Clean Code/ 从根本上低估了注释, 这是必不可少且不可替代的. 这是以巨大的代价为代价的. 如果没有接口注释, 接口的规范是不完整的. 这肯定会导致混乱和错误. 如果没有实现注释, 读者将被迫重新推导出原始开发人员脑海中的知识和意图. 这浪费了时间并导致了更多错误.

在我的开场白中, 我说过, 当开发人员无法访问和不明显的重要信息时, 系统就会变得复杂. 通过拒绝编写注释, 你隐藏了你拥有的, 其他人需要的重要信息.

/Clean Code/ 中的第二个一般性错误与平衡有关. 设计代表了相互竞争的关注点之间的平衡. 几乎任何设计理念如果走向极端都会变成一件坏事. 然而, /Clean Code/ 反复在一个方向上给出非常强烈的建议, 而没有在另一个方向上给出相应的强烈建议, 也没有提供任何有意义的指导来帮助你识别何时走得太远. 例如, 缩短方法通常是一件好事, 但 /Clean Code/ 的立场是如此片面和极端, 以至于读者可能会把事情分解得太多. 我们在 =PrimeGenerator= 示例中看到, 这如何导致代码几乎难以理解. 同样, /Clean Code/ 在 TDD 上的立场是片面的, 未能认识到任何可能的弱点, 并鼓励读者将此视为战术极端, 其中设计完全被挤出开发过程.

*UB:*

John, 我要感谢你参与这个项目. 这对我来说很有趣. 我喜欢与聪明人分歧和辩论. 我也认为我们共同的价值观远多于分离我们的价值观.

就我而言, 我只想说我已经充分考虑了你提出的观点, 虽然我不同意你上面的结论, 但我已经整合了你的一些更好的想法, 以及整个文档, 到 _Clean Code_ 的第二版中.

再次感谢, 并向你的学生致以最美好的祝愿.
